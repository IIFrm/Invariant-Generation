%!TEX root = paper.tex

\section{Evaluation} % (fold)
\label{sec:evaluations}
We have implemented our invariant inference framework in a tool, called \textsc{Zilu}. \textsc{Zilu} is written using a combination of C++ as well as shell codes (for invoking external tools).
\textsc{Zilu} makes use of GSL~\cite{gough2009gnu} to solve equation systems which is necessary for selective sampling and
%% uses
 LibSVM~\cite{chang2011libsvm} as a primitive classification engine for
SVM-based classification. %% based on SVM.
For candidate verification, we %% reuse a large part of
modify the KLEE project~\cite{cadar2008klee} to
symbolically execute
%% generate verification conditions for
 C programs %% and use
prior to invoke Z3~\cite{de2008z3} for checking satisfiability of
condition (4), (5) and (6).
 We remark that KLEE is a symbolic executor; it may
concretely execute the programs and return
 under-approximated
abstraction. This may affect the soundness of our system.
To overcome this problem, we detect those path conditions produced from
concrete executions
and return sound abstraction (i.e. $true$) for them.
 %% KLEE was designed for test case generation and thus its default encoding may result in under-approximation of the program behavior. We have re-implemented the relevant part of KLEE to make sure the right verification conditions are generated.

%Our test subjects include a set of 32 benchmark programs %% which we
%either gathered from the previous publications~\cite{gulwani2008program}\cite{sharma2012interpolants} \cite{gulavani2008automatically} and from
%the software verification competition repository~\cite{beyer:SVCOMP:2013}\cite{Dirk:SVCOMP:2016}
%{or constructed by ourselves}.


\LJ{
To study the effectiveness of \textsc{Zilu}, we chose small C programs as benchmarks from multiple sources, including papers, other tool test suite.
The benchmark $f2, xy*, pldi08$ are from publications~\cite{gulwani2008program}\cite{sharma2012interpolants} and \cite{gulavani2008automatically}.
The benchmark $interproc*$ are from ~\cite{jeannet2010interproc}.
The benchmark $zilu\_*$ are constructed by ourselves.
The benchmark $terminator\_01\_safe$ is gathered from ~\cite{beyer:SVCOMP:2013} and the others are collected from ~\cite{Dirk:SVCOMP:2016}.
All benchmarks are available from~\cite{zilu:benchmark}.
}
%% Note
We remark that the loops in these benchmark programs often contain non-deterministic choices
%% in the loop
which are used to model I/O environment (e.g., an external function call).
As non-determinism is beyond the scope of this paper, we syntactically replace these non-deterministic commands with free variables of type boolean. In the future, we would like to investigate how to learn loop invariants in the presence of non-determinism (e.g., random number generation in the loop).
%It would be interesting to investigate how our active learning verification system can be extended to infer non-determinism-based invariants.
 %% which by our assumption is not allowed. We thus transform the programs so that free boolean-type variables are introduced to replace the non-deterministic choice. We remark that the assumption of no non-determinism is less a problem for verification programs in practice as they are often deterministic. These benchmark programs are made non-deterministic often as a way of abstracting away certain complicated (e.g., an external function call) part of the program which is irrelevant to proving/disproving the Hoare triple.
%In our experimental evaluation,
%we test \textsc{Zilu} with \LL{Number} loop invariant benchmarks
%in the following form, where $\mathit{Body}$ can have nested loops and conditional choices.
%\[
%   \{ \mathit{Pre} \} \mathit{while}(\mathit{Cond}) \{ \mathit{Body} \} \{ \mathit{Post} \}
%\]
%% Do not apply this to `add' more content to the paper.
%% It lefts lots of empty space which did the contrary thing.
%% \begin{align*}
%% &Pre&\\
%% &while (Cond) \{&\\
%% &  \quad Body &\\
%% &\} &\\
%% &Post &
%% \end{align*}
%\LL{Introduce the sources of the benchmark.}
 %% All benchmarks are available from~\cite{zilu}.

The parameters chosen in our experiments are set as follows. For random sampling, we generate random values of all input variables of the program from their default ranges. Be default, we generate 8 random values for each free variable.
%which would be enlarged if we can not find samples in a few tries.
%Our experiments indicate this $\mathcal{R}$ is a relatively rational range for the initial sampling.
When we invoke LibSVM, the parameter $C$ (i.e., the preference between avoiding misclassifying each training example and enlarging decision boundary) and the inner iteration for SVM learning are set to their maximum value so as to generate only perfect classifiers. 
Each invocation of LibSVM's classification engine is set to time out in 600 seconds. 
The maximum degree for learning polynomial classifiers is set to be 4. For candidate verification, we encode integer-type variables in the programs as integers in Z3.


%Considering the differences between machine learning problem and our setting,
%\textsc{Zilu} tunes $\textsc{LibSvm}$~\cite{chang2011libsvm} in the following three aspects in order to get a \underline{perfect classifier}.
%\begin{itemize}
%\item Convert \textsc{Svm} model to an explicit classifier.
%The original \textsc{Svm} technique does not explicitly calculate a hyperplane, but emits its own model
%which can be used to do prediction on the given data.
%%This might not a big problem if we do not apply $\textsc{Svm}$ with some kernel method (which is used to classify no linear separable data).
%However, we need a explicit classifier as the loop invariant candidate which can be understood and proceeded later for verification.
%(This is also why we do not apply $\textsc{Svm}$ with kernel methods~\cite{yu2009evolving},
%considering converting $\textsc{Svm}$ models with kernel methods, i.e. $\textsc{Rbf}$ kernel, would be a complicated, sometimes even impossible, task.)
%
%\item As \textsc{Zilu} treasures classification accuracy on the training dataset% than anything else,
%before applying primitive $\textsc{Svm}$ technique, the parameters
%(mainly $C$ which tells the $\textsc{Svm}$ optimization how much you want to avoid misclassifying each training example)
%%different from $\mathcal{C}$ used as loop invariant candidate in our context)
%should be carefully tuned to learn a perfect classifier which perform well on the training points.
%
%\item Validating the learned classifier.
%Checking the classification correctness of the learned classifier
%on $\mathcal{S}^+$ and $\mathcal{S}^-$ is still needed as our setting needs to ensure the learned classifier is a perfect one.
%\textsc{Zilu} also takes $\mathcal{S}^\rightarrow$ to validate the learned classifier(as is shown in Section~\ref{sec:sampling}).
%\end{itemize}

%\begin{table}[t]
%\scriptsize
%\centering
%\caption{Experiment results}
%%\begin{tabular}{l c | c c c c | c c c c | c c }
%%\cline{3-10}
%\begin{tabular}{l c | c c c c| c c c | c c }
%\cline{3-9}
%%& &\multicolumn{4}{|c|}{\textsc{Zilu} with Selective}&\multicolumn{4}{c|}{\textsc{Zilu} without Selective} & & \\
%& &\multicolumn{4}{|c|}{\textsc{Zilu} with Selective}&\multicolumn{3}{c|}{\textsc{Zilu} without Selective} & & \\
%\hline
%%\multicolumn{1}{|c|}{benchmark}&\multicolumn{1}{|c|}{inv type}& $\sharp$r. sample & $\sharp$s. sample & $\sharp$v. sample & time & $\sharp$r. sample & & $\sharp$v. sample & time & \multicolumn{1}{|c|}{Interproc} & \multicolumn{1}{|c|}{CPAChecker} \\
%\multicolumn{1}{|c|}{benchmark}&\multicolumn{1}{|c|}{inv type}& $\sharp$r. sample & $\sharp$s. sampls & $\sharp$v. sample &time(s) & $\sharp$r. sample & $\sharp$v. sample &time(s) & \multicolumn{1}{|c|}{Interproc} & \multicolumn{1}{|c|}{CPAChecker} \\
%\hline % inserts single horizontal line
%\multicolumn{1}{|c|}{afnp2014\_true\text{-}unreach\text{-}call}         	&conjunction	&248 &992 &27 &39.33	&5160 &129 &timeout  & &  \\
%%\multicolumn{1}{|c|}{afnp2014\_true\text{-}unreach\text{-}call}         	&conjunction	&248 &993 &27 &39.33	&5160 & &223.63  & &  \\
%\multicolumn{1}{|c|}{cav12foo1}         									&conjunction 	&228 &912 &20 &51.07	&1980 &48 &168.97  & &  \\
%\multicolumn{1}{|c|}{cav12foo2}         									&conjunction 	&36 &144 &2 &16.09		&260 &6 &15.98  & &  \\
%%\multicolumn{1}{|c|}{cggmp2005\_variant\_true\text{-}unreach\text{-}call}   &conjunction 	&210 &840 & &74045	&2220 & &timeout  & &  \\
%\multicolumn{1}{|c|}{cggmp2005\_variant\_true}   							&conjunction 	&204 &816 &13 &108.57	&1620 &24 &timeout  & &  \\
%\multicolumn{1}{|c|}{conj}         											&polynomial 	&10 &40 &2 &20.48		&70 &1 &28.48  & &  \\
%%\multicolumn{1}{|c|}{conj}         											&conjunction/polynomial & & &  &   &  & & &  & &  \\
%\multicolumn{1}{|c|}{css2003\_true\text{-}unreach\text{-}call}         		&conjunction 	&324 &1296 &33 &57.78	&5080 &125 &258.65  & &  \\
%\multicolumn{1}{|c|}{dis}         											&polynomial 	&22 &88 &1 &24.27  &70   &2 &41.62  & &  \\
%\multicolumn{1}{|c|}{down\_true\text{-}unreach\text{-}call\_1}         		&conjunction 	&264 &1056 &15 &116.21  &1770  &27  &timeout  & &  \\
%\multicolumn{1}{|c|}{down\_true\text{-}unreach\text{-}call\_2}         		&conjunction 	&222 &888 &14 &52.96  &720 &10   &44.99  & &  \\
%\multicolumn{1}{|c|}{f2}         											&linear 		&52 &208 &1 &10.15  &120 &1   &12.03  & &  \\
%\multicolumn{1}{|c|}{f3}         											&linear 		&36 &144 &1 &105.15  &330  &5  &93.04  & &  \\
%%\multicolumn{1}{|c|}{fig1a\_1}         										&linear & & &  &   &  & & &  & &  \\
%%\multicolumn{1}{|c|}{fig1a\_2}         										&linear & & &  &   &  & & &  & &  \\
%\multicolumn{1}{|c|}{interproc\_test1}         								&linear 		&8 &32 &1 &9.21  &40 &2   &10.38  & &  \\
%\multicolumn{1}{|c|}{interproc\_test2}         								&linear 		&84 &96 &1 &11.66  &240  &1  &171.14  & &  \\
%\multicolumn{1}{|c|}{interproc\_test3}         								&linear 		&42 &168 &1 &30.32  &420 &5   &43.34  & &  \\
%\multicolumn{1}{|c|}{interproc\_test4}         								&linear 		&28 &112 &4 &14.8  &240 &5   &38.25  & &  \\
%\multicolumn{1}{|c|}{interproc\_test5}         								&linear 		&32 &128 &1 &9.18  &180 &3   &28.05  & &  \\
%\multicolumn{1}{|c|}{interproc\_test6}         								&polynomial 	&6 &24 &1 &11.83  &70  &2  &18.27  & &  \\
%\multicolumn{1}{|c|}{interproc\_test8}         								&conjunction 	&24 &96 &6 &22.13  &220  &2  &97.47  & &  \\
%\multicolumn{1}{|c|}{interproc\_test11}         							&linear 		&24 &96 &2 &24.79  &180 &2   &206.07  & &  \\
%\multicolumn{1}{|c|}{lili2}         										&linear 		&84 &336 &4 &21.28  &720  &9  &82.24  & &  \\
%\multicolumn{1}{|c|}{linear6}         										&linear 		&18 &72 &1 &16.19  &270 &3  &179.39  & &  \\
%\multicolumn{1}{|c|}{multivar\_true\text{-}unreach\text{-}call1}         	&conjunction 	&68 &272 &3 &16.84  &220 &4   &15.22  & &  \\
%\multicolumn{1}{|c|}{terminator\_01\_safe}         							&linear 		&6 &24 &1 &9.2  &90  &4  &13.06  & &  \\
%\multicolumn{1}{|c|}{test}         											&linear 		&28 &112 &1 &10.19  &420 &2  &24.51  & &  \\
%\multicolumn{1}{|c|}{test2}         										&conjunction 	&56 &218 &3 &173.09  &280  &7  &timeout  & &  \\
%%\multicolumn{1}{|c|}{up\_true\text{-}unreach\text{-}call\_1}         		&conjunction & & &  &   &  & & &  & &  \\
%\multicolumn{1}{|c|}{up\_true\text{-}unreach\text{-}call\_2}         		&conjunction 	&240 &960 &14 &84.02  &540 &7   &89.77  & &  \\
%%\multicolumn{1}{|c|}{xeq10}         										&linear & & &  &   &  & & &  & &  \\
%\multicolumn{1}{|c|}{xle10}         										&linear 		&6 &24 &1 &8.57  &60 &3   &12.58  & &  \\
%\multicolumn{1}{|c|}{xy10}         											&linear 		&162 &648 &4 &39.69  &840  &11  &40.51  & &  \\
%\multicolumn{1}{|c|}{xyle0}         										&polynomial 	&60 &240 &4 &85.61  &620   &12 &472.68  & &  \\
%\hline
%\end{tabular}
%\label{tbl:stats}
%\end{table}

%\begin{table*}[t]
%    \begin{center}
%    % \begin{minipage}{\textwidth}
%    % \begin{adjustwidth}{-1in}{-1in}
%    \begin{center}
%    \begin{adjustbox}{max width=1\textwidth}
%    \begin{tabular}{l | r | r | r | r | r | r | r | r | r}
%        \hline\hline
%        Benchmark
%            & $\sharp$Random Samples & $\sharp$Selective Samples & $\sharp$Iterations
%            & $\sharp$Traces & $\sharp$Variables
%            & Time & Invariant Type
%            & Interproc & CPAChecker
%            \\
%        \hline
%        Linear 1
%            & 196 & 4 & 1
%            & 1 & 1
%            & 3.31s & Linear
%            & 0.01s & 3.42s
%            \\
%        \hline
%        Linear 2
%            & 3158 & 7 & 1
%            & 1 & 2
%            & 9.86s & Linear
%            & 0.01s & 3.29s
%            \\
%        \hline
%        Linear 3
%            & 11102 & 6 & 1
%            & 1 & 3
%            & 40.24s & Linear
%            & 0.01s & 3.50s
%            \\
%        \hline
%        Linear 4
%            & 1143 & 10 & 1
%            & 9 & 2
%            & 12.54s & Linear
%            & 0.01s & 3.76s
%            \\
%        \hline
%        Linear 5
%            & 918 & 8 & 2
%            & 3 & 2
%            & 14.47s & Linear
%            & Error & 3.66s
%            \\
%        \hline
%        Poly 1
%            & 64 & 7 & 2
%            & 1 & 1
%            & 10.51s & Polynomial
%            & Unknown & Unknown
%            \\
%        \hline
%        Poly 2
%            & 32711 & 85 & 7
%            & 2 & 2
%            & 23m43.1s & Polynomial
%            & Unknown & Unknown
%            \\
%        \hline
%        Poly 3
%            & 272 & 17 & 4
%            & 3 & 1
%            & 15.82s & Polynomial
%            & 0.01s & 3.31s
%            \\
%        \hline
%        Poly 4
%            & 2287 & 112 & 9
%            & 2 & 2
%            & 13m43.7s & Polynomial
%            & Unknown & Unknown
%            \\
%        \hline
%        Conjunction 1
%            & 21247 & 81 & 1
%            & 3 & 2
%            & 20m41.35s & Conjunction
%            & 0.01s & 3.16s
%            \\
%        \hline
%    \end{tabular}
%    \end{adjustbox}
%    \end{center}
%    % \end{adjustwidth}
%    % \end{minipage}
%    \end{center}
%    \caption{Experiment Results}
%    \label{tab:experiments}
%\end{table*}

We compare \textsc{Zilu} with two state-of-the-art invariant inference tools: Interproc~\cite{jeannet2010interproc} and CPAChecker~\cite{beyer2011cpachecker}. %Though many others have been reported~\cite{}, most of which are not maintained any more. 
We remark that the comparison between \textsc{Zilu} and Interproc or CPAChecker should be taken with a grain of salt as the methods for invariant generation are  different. Interproc is based on abstract interpretation. In the experiments, Interproc uses its most expressive abstract domain, i.e., the reduced product of polyhedra and linear congruences abstraction. Similar to \textsc{Zilu}, Interproc explicitly labels the loop invariants in the loop program. We thus can manually check their correctness and compare them with the invariants generated by \textsc{Zilu}. CPAChecker (formerly BLAST~\cite{henzinger2003software}) is a software verification tool based on the framework of configurable program analysis~\cite{beyer2007configurable}. In the experiments, CPAChecker is configured to generate loop invariants to prove the same Hoare triple. In addition, we measure the performance of \textsc{Zilu} with or without active learning in order to show the relevance of selective sampling.

\begin{table}[t]
\scriptsize
\centering
\caption{Experiment results}
\begin{tabular}{l c | c c c | c c c | c c }
\cline{3-8}
& &\multicolumn{3}{|c|}{\textsc{Zilu} - Selective Sampling}&\multicolumn{3}{c|}{\textsc{Zilu} - Random Sampling} & & \\
\hline
\multicolumn{1}{|c|}{benchmark}&\multicolumn{1}{|c|}{inv type}& $\sharp$sample & $\sharp$iteration & time(s) & $\sharp$sample & $\sharp$iteration &time(s) & \multicolumn{1}{|c|}{Interproc} & \multicolumn{1}{|c|}{CPAChecker} \\
\hline % inserts single horizontal line
%\multicolumn{1}{|c|}{TEMPLATE} 		        	&polynomial 	& & &  &  &  &  & &  \\
%\hline
\multicolumn{1}{|c|}{f2}         						&linear 		&260 &1 &\textbf{10.15}  		&120 &1   &12.03  			&\cmark &  \\
\multicolumn{1}{|c|}{xy10} 	        					&linear 		&810 &4 &\textbf{39.69} 		&840  &11  &40.51  			&\cmark &  \\
\multicolumn{1}{|c|}{xyz}   	      					&linear 		&180 &1 &105.15  				&330  &5  &\textbf{93.04}  	&\cmark &  \\
\multicolumn{1}{|c|}{xy0\_1}         					&conjunction 	&1140 &20 &\textbf{51.07}		&1980 &48 &168.97  			&\cmark &  \\
\multicolumn{1}{|c|}{xy0\_2}         					&conjunction 	&180  &2 &16.09					&260 &6 &\textbf{15.98}  	&\cmark &  \\
\multicolumn{1}{|c|}{pldi08} 		        			&disjunction 	&500 &1 &timeout  				&120  &2  &timeout  		&\xmark &  \\

%\hline
\multicolumn{1}{|c|}{interproc1}         				&linear 		&40 &1 &\textbf{9.21}  			&40 &2   &10.38  			&\cmark &  \\
\multicolumn{1}{|c|}{interproc2}         				&linear 		&600 &1 &\textbf{11.66} 		&240  &1  &171.14  			&\cmark &  \\
\multicolumn{1}{|c|}{interproc3}         				&linear 		&210 &1 &\textbf{30.32}  		&420 &5   &43.34  			&\cmark &  \\
\multicolumn{1}{|c|}{interproc4}         				&linear 		&140 &4 &\textbf{4.8}  			&240 &5   &38.25  			&\xmark &  \\
\multicolumn{1}{|c|}{interproc5}         				&linear 		&160 &1 &\textbf{9.18}  		&180 &3   &28.05  			&\cmark &  \\

%\hline
\multicolumn{1}{|c|}{zilu\_linear1}         			&linear 		&120 &2 &\textbf{24.79}  		&180 &2   &206.07  			&\xmark &  \\
\multicolumn{1}{|c|}{zilu\_linear2}         			&linear 		&420 &4 &\textbf{21.28}  		&720  &9  &82.24  			&\cmark &  \\
\multicolumn{1}{|c|}{zilu\_linear3}         			&linear 		&90 &1 &\textbf{16.19}  		&270 &3  &179.39  			&\cmark &  \\
\multicolumn{1}{|c|}{zilu\_linear4}         			&linear 		&140 &1 &\textbf{10.19}  		&420 &2  &24.51  			&\cmark &  \\
\multicolumn{1}{|c|}{zilu\_linear5}         			&linear 		&30 &1 &\textbf{8.57}  			&60 &3   &12.58  			&\cmark &  \\

\multicolumn{1}{|c|}{zilu\_poly1}         				&polynomial 	&50 &2 &\textbf{20.48}			&70 &1 &28.48  				&\xmark &  \\
\multicolumn{1}{|c|}{zilu\_poly2}         				&polynomial 	&110  &1 &\textbf{24.27}  		&70   &2 &41.62  			&\xmark &  \\
\multicolumn{1}{|c|}{zilu\_poly3}         				&polynomial 	&30 &1 &\textbf{11.83}  		&70  &2  &18.27  			&\xmark &  \\
\multicolumn{1}{|c|}{zilu\_poly4}         				&polynomial 	&1500 &5 &timeout  				&560  &2  &timeout 			&\xmark & \\
\multicolumn{1}{|c|}{zilu\_poly5}         				&polynomial 	&3400 &14 &timeout  			&800  &12  &timeout  		&\xmark &  \\
\multicolumn{1}{|c|}{zilu\_poly6}         				&polynomial 	&300 &4 &\textbf{85.61}  		&620   &12 &472.68  		&\xmark &  \\

\multicolumn{1}{|c|}{zilu\_conj1}         				&conjunction 	&120 &6 &\textbf{22.13}  		&220  &2  &97.47  			&\xmark &  \\
\multicolumn{1}{|c|}{zilu\_conj2}         				&conjunction 	&280 &3 &\textbf{173.09}  		&280  &7  &timeout  		&\cmark &  \\

%\hline
\multicolumn{1}{|c|}{terminator\_01\_safe}         		&linear 		&30 &1 &\textbf{9.2}  			&90  &4  &13.06  			&\cmark &  \\
%\hline
\multicolumn{1}{|c|}{afnp2014\_true}         			&conjunction	&1240 &27 &\textbf{39.33}		&5160 &129 &timeout  		&\xmark &  \\
\multicolumn{1}{|c|}{multivar\_true\_1}         		&conjunction 	&340 &3 &16.84  				&220 &4   &\textbf{15.22}  	&\cmark &  \\
\multicolumn{1}{|c|}{cggmp2005\_variant}   				&conjunction 	&1020 &13 &\textbf{108.57}		&1620 &24 &timeout  		&\cmark &  \\
\multicolumn{1}{|c|}{css2003\_true}         			&conjunction 	&1420 &33 &\textbf{57.78}		&5080 &125 &258.65  		&\cmark &  \\
\multicolumn{1}{|c|}{up\_true\_2}         				&conjunction 	&1200 &14 &\textbf{84.02}  		&540 &7   &89.77  			&\cmark &  \\
\multicolumn{1}{|c|}{down\_true\_1}         			&conjunction 	&1320  &15 &\textbf{116.21}  	&1770  &27  &timeout  		&\cmark &  \\
\multicolumn{1}{|c|}{down\_true\_2}         			&conjunction 	&1110 &14 &52.96  				&720 &10   &\textbf{44.99}  &\cmark &  \\

\hline
\end{tabular}
\label{tbl:stats}
\end{table}

The experiment results are presented in Table~\ref{tbl:stats}. All of the experiments are conducted using x64 Ubuntu 14.04.1 (kernel 3.19.0-59-generic) with 3.60 GHz Intel Core i7 and 32G DDR3.
The first column shows which a name of the benchmark program. 
The second shows the type of invariant required for proving the Hoare triple. 
The next three columns present details on \textsc{Zilu}, i.e., the number of samples, the number of iterations and the execution time. 
The next three columns present the corresponding statistics obtained by running \textsc{Zilu} without selective sampling. 
The last two columns show the execution time of Interproc and CPAChecker if it manages to generate a correct invariant.
%%\LL{I need more information on the percentage of the samples. }
%`$\sharp$Invariants' stands the numbers of invariants generated by SVM,
%and `$\sharp$Iterations' represents the number of invariant candidates.
%Notice that an invariant generated by SVM becomes an invariant candidate
%when it converges to two previously generated invariants from SVM in one iteration process.
%`$\sharp$Traces' represents the number of loop body traces produced by KLEE~\cite{cadar2008klee}.
%and `$\sharp$Variables' represents the number of program variables.
% In general, when numbers of traces and variables increase in a program,
% the invariant inference difficulty increases.
%The seventh column gives the time used for the invariant generation
%and the eighth column gives the invariant type of the generated invariant.
%We remark that since \textsc{Zilu} relies on random sampling, all numbers collected from \textsc{Zilu} in the table are the average of 10 experiments.

We have the following observations based on the experiment results. 

First, selective sampling is helpful in reducing the number of learn-and-check iterations. 
On average, the number of iterations is reduced from 10.84 to 4.96. As a result, the time required for proving the program is reduced by a factor of XXX. 
We would like to highlight that for 13 out of 32 cases, \textsc{Zilu} is able to learn the correct invariant with one iteration, whereas this is only the case for 3 programs without selective sampling. It implies that even if there is no verifier, \textsc{Zilu} may be able to learn the correct invariant. 
This is particularly useful if the loop body to beyond the capability of existing program verifiers. 
That is, in such a case, \textsc{Zilu} would generate an invariant which can be used to manually verify the program, whereas \textsc{Zilu} without selective sampling would not be able to help. 

Second, \textsc{Zilu} is reasonably efficient. All loop invariants are learned within three minutes. It implies that selective sampling converges reasonably fast. 
\LJ{We do notice that most experiments with conjunctive form of invariants take much longer time than the rest,
which is due to our $conjunctivePoly$ algorithm calls the primary \textsc{svm} many more times in one classification round while other algorithms only call it once. 
We also notice that some experiments with polynomial invariants (\emph{zilu\_poly4}, \emph{zilu\_poly5}) can not get a classifier until run overtime. 
The reason is the samples on the projected space are discrete on the integer domain while the samples on the original space are continuous.
For example, as an integer, variable $x$ can be any value in set \{$\cdots, -1, 0, 1, 2, 3, \cdots$\}, which is continuous on integer domain.
However, after mapping to degree 2, $(x, x^2)$ can be defined only in set \{$\cdots, (-1,1), (0,0), (1,1), (2, 4), (3, 9)\cdots$\}, which leaves many points are undefined, such as $(1, 3), (2, 1)$.
And thus it makes the convergence of our learning algorithms much more difficult with these undefined holes.
What's more, the problem becomes much worse as the degree increases, as these undefined holes contains much more points than the defined samples, which is also the reason that we restrict the degree of our $polynomial$ algorithm up to 4. }

%To illustrate the reason, consider the case of benchmark \emph{poly 1}, the loop invariant is $x^2 \le y^2$.
%However, the general form of an order-2 polynomial with 2 variables
%is: $a \cdot x^2 + b \cdot y^2 + c \cdot x y + d \cdot x + e \cdot y + f \geq 0$. It takes XXX iterations before $c$, $d$, $e$ and $f$ to converge to 0.
Lastly, \textsc{Zilu} complements existing tools. For instance, \textsc{Zilu} can automatically generate polynomial loop invariants
which are beyond the capability of Interproc or CPAChecker. It can be observed that both Interproc and CPAChecker run faster than \textsc{Zilu} if they can learn the correct invariant. 
However, the invariant generated by Interproc may not be correct. 
This can be demonstrated using our running example introduced in Section~\ref{sec:introduction}. 
Since we have the loop condition $x < y$, it is impossible to execute the loop body when $(x \ge 0) \land (y < 0)$. 
However, Interproc outputs the loop invariant corresponding to this execution trace,
because the invariants in Interproc are global constraints
without considering their generation paths and conditions.

% section evaluations (end)
