%!TEX root = paper.tex

\section{Evaluations} % (fold)
\label{sec:evaluations}


\begin{table*}[t]
    \begin{center}
    % \begin{minipage}{\textwidth}
    % \begin{adjustwidth}{-1in}{-1in}
    \begin{center}
    \begin{adjustbox}{max width=1\textwidth}
    \begin{tabular}{l | r | r | r | r | r | r | r | r | r}
        \hline\hline
        Benchmark 
            & $\sharp$Samples & $\sharp$Invariants & $\sharp$Iterations 
            & $\sharp$Traces & $\sharp$Variables
            & Time & Invariant Type 
            & Interproc & CPAChecker 
            \\
        \hline
        Linear 1
            & 196 & 4 & 1 
            & 1 & 1
            & 3.31s & Linear 
            & 0.01s & 3.42s
            \\
        \hline
        Linear 2
            & 3158 & 7 & 1 
            & 1 & 2
            & 9.86s & Linear 
            & 0.01s & 3.29s
            \\
        \hline
        Linear 3
            & 11102 & 6 & 1
            & 1 & 3
            & 40.24s & Linear 
            & 0.01s & 3.50s
            \\
        \hline
        Linear 4
            & 1143 & 10 & 1
            & 9 & 2
            & 12.54s & Linear 
            & 0.01s & 3.76s
            \\
        \hline
        Linear 5
            & 918 & 8 & 2 
            & 3 & 2
            & 14.47s & Linear 
            & Error & 3.66s
            \\
        \hline
        Poly 1
            & 64 & 7 & 2
            & 1 & 1 
            & 10.51s & Polynomial 
            & Unknown & Unknown 
            \\
        \hline
        Poly 2 
            & 32711 & 85 & 7 
            & 2 & 2
            & 23m43.1s & Polynomial
            & Unknown & Unknown 
            \\
        \hline
        Poly 3 
            & 272 & 17 & 4 
            & 3 & 1 
            & 15.82s & Polynomial 
            & 0.01s & 3.31s 
            \\
        \hline
        Poly 4 
            & 2287 & 112 & 9
            & 2 & 2
            & 13m43.7s & Polynomial
            & Unknown & Unknown 
            \\
        \hline
        Conjunction 1
            & 21247 & 81 & 1 
            & 3 & 2 
            & 20m41.35s & Conjunction
            & 0.01s & 3.16s
            \\
        \hline
    \end{tabular}
    \end{adjustbox}
    \end{center}
    % \end{adjustwidth}
    % \end{minipage}
    \end{center}
    \caption{Experiment Results}
    \label{tab:experiments}
\end{table*}

In this work, we implement our invariant inference framework into a tool called \textsc{Zilu}, 
written in C++ and shell code. 
\textsc{Zilu} uses GSL~\cite{gough2009gnu} to solve equation system which is used in selective sampling, 
LibSVM~\cite{chang2011libsvm}, which source code is embeded, as primitive classification engine for learning classifier, 
KLEE\cite{cadar2008klee} as a symbolic execution tool to emit path constraints 
and Z3~\cite{de2008z3} solver for constraint solving and verification. 
In our experimental evaluation, 
we test \textsc{Zilu} with \LL{Number} loop invariant benchmarks 
in the following form, where $\mathit{Body}$ can have nested loops and conditional choices. 
%\[
%    \{ \mathit{Pre} \} \mathit{while}(\mathit{Cond}) \{ \mathit{Body} \} \{ \mathit{Post} \}
%\]
\begin{align*}
&Pre&\\
&while (Cond) \{&\\
&  \quad Body &\\
&\} &\\
&Post &
\end{align*}
\LL{Introduce the sources of the benchmark.}
All benchmarks are available from~\cite{zilu}. 

The parameters chosen in our experimental evaluation can be elaborated as follows. 
In the \emph{Sampling} stage, 
the values of all of the program input variables in the random sampling 
and the chosen variables in the selective sampling 
follow the universal distribution over the range of $\mathcal{R} = [-200, 200]$ initially,
which would be enlarged if we can not find samples in a few tries.
Our experiments indicate this $\mathcal{R}$ is a relatively rational range for the initial sampling.
In the \emph{Classification} stage, 
the parameter $C$, 
which tells the preference between avoiding misclassifying each training example and enlarging decision boundary,
and the inner iteration 
for $\textsc{Svm}$ learning are set to their maximum value 
in order to generate a perfect classifier which works well on the training set. 
In the \emph{Verification} stage, 
the Z3 solver uses `integer' as the type of the program variables. 

To evaluate the effectiveness of \textsc{Zilu}, 
we compared it with two available state-of-the-art invariant inference tools: 
Interproc~\cite{cite} and CAPChecker~\cite{cite}, 
which correspond to two different invariant generation methods. 
Interproc is based on abstract interpretation. 
In the experiment, Interproc uses its most expressive abstract domain, i.e., 
the reduced product of polyhedra and linear congruences abstraction. 
Similar to \textsc{Zilu}, Interproc explicitly labels the loop invariants in the loop program. 
We thus can manually check their correctness
and compare them with the invariants generated by our tool \textsc{Zilu}. 
On the other hand, CPACheck (formerly named after BLAST~\cite{cite}) is a software verification tool 
based on the framework of configurable program analysis~\cite{cite}. 
In the experiment, we ask it to generate loop invariants for the program predicate abstraction. 
Since CPAChecker functions by proving the program correctness, 
we insert an error branch after each loop program and check for the reachability of the error. 

We present the experiment results in Table~\ref{tab:experiments}. 
Since our invariant reference method has random factors introduced by the sampling sources, 
the presented results are those with median running time in $9$ times of invariant reference process. 
All of the experiments are conducted using x86\_64 Ubuntu 14.04 (kernel 3.13.0-85-generic) 
with 2.3 GHz Intel Core i5 and 4G 1333MHz DDR3. 
In Table~\ref{tab:experiments}, the second column to the seventh column correspond to 
invariant generation details from \textsc{Zilu}. 
`$\sharp$Samples' represents the number of samples generated in the experiment, 
including those from random sampling, selective sampling, and counter-example sampling. 
\LL{I need more information on the percentage of the samples. }
`$\sharp$Invariants' stands the numbers of invariants generated by SVM, 
and `$\sharp$Iterations' represents the number of invariant candidates. 
Notice that an invariant generated by SVM becomes an invariant candidate 
when it converges to two previously generated invariants from SVM in one iteration process. 
`$\sharp$Traces' represents the number of loop body traces produced by KLEE\cite{cadar2008klee}. 
and `$\sharp$Variables' represents the number of program variables. 
% In general, when numbers of traces and variables increase in a program, 
% the invariant inference difficulty increases. 
The seventh column gives the time used for the invariant generation 
and the eighth column gives the invariant type of the generated invariant. 

As can be seen from Table~\ref{tab:experiments}, 
some of the experiments take much longer time comparing with others, 
with high numbers of samples, invariants, iterations. 
The reason behind this is 
that some variables are missing in the constraints of the loop invariant, 
e.g., `Poly 2', `Poly 4' and `Conjunction 1'.  
For instance, in the `Poly 1' case, the loop invariant is `$x^2 \le y^2$'. 
However, the general form of a 2-order polynomial with 2 variables 
is written as 
\[
    a \cdot x^2 + b \cdot y^2 + c \cdot x y + d \cdot x + e \cdot y + f \le 0. 
\] 
Hence, we need to infer $c = d = e = f = 0$ 
which causes the difficulty of invariant inference. 

The last two columns show the analysis results from Interproc and CPAChecker. 
As can be seen, Interproc is extremely fast. 
However, the invariant given by Interproc can be incorrect, 
which can be demonstrated by the running example 
that we introduced in Section~\ref{sec:introduction}. 
In the running example, since we have $x < y$ constrained by the while loop condition, 
it is thus impossible to execute the trace where $(x \ge 0) \land (y < 0)$. 
However, Interproc outputs the loop invariant corresponding to this execution trace, 
because the invariants in Interproc are global constraints 
without considering their generation paths and conditions. 
Both of Interproc and CPAChecker are faster than our tool \textsc{Zilu}. 
On the other hand, \textsc{Zilu} can automatically generate polynomial loop invariants 
which cannot be handled by Interproc and CPAChecker. 

% section evaluations (end)
