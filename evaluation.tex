%!TEX root = paper.tex

\section{Evaluations} % (fold)
\label{sec:evaluations}


\begin{table*}[t]
    \begin{center}
    % \begin{minipage}{\textwidth}
    % \begin{adjustwidth}{-1in}{-1in}
    \begin{center}
    \begin{adjustbox}{max width=1\textwidth}
    \begin{tabular}{l | r | r | r | r | r | r | r | r | r}
        \hline\hline
        Benchmark 
            & $\sharp$Samples & $\sharp$Invariants & $\sharp$Iterations 
            & $\sharp$Traces & $\sharp$Variables
            & Time & Invariant Type 
            & Interproc & CPAChecker 
            \\
        \hline
        Linear 1
            & 196 & 4 & 1 
            & 1 & 1
            & 3.31s & Linear 
            & 0.01s & 3.42s
            \\
        \hline
        Linear 2
            & 3158 & 7 & 1 
            & 1 & 2
            & 9.86s & Linear 
            & 0.01s & 3.29s
            \\
        \hline
        Linear 3
            & 11102 & 6 & 1
            & 1 & 3
            & 40.24s & Linear 
            & 0.01s & 3.50s
            \\
        \hline
        Linear 4
            & 1143 & 10 & 1
            & 9 & 2
            & 12.54s & Linear 
            & 0.01s & 3.76s
            \\
        \hline
        Linear 5
            & 918 & 8 & 2 
            & 3 & 2
            & 14.47s & Linear 
            & Error & 3.66s
            \\
        \hline
        Poly 1
            & 64 & 7 & 2
            & 1 & 1 
            & 10.51s & Polynomial 
            & Unknown & Unknown 
            \\
        \hline
        Poly 2 
            & 32711 & 85 & 7 
            & 2 & 2
            & 23m43.1s & Polynomial
            & Unknown & Unknown 
            \\
        \hline
        Poly 3 
            & 272 & 17 & 4 
            & 3 & 1 
            & 15.82s & Polynomial 
            & 0.01s & 3.31s 
            \\
        \hline
        Poly 4 
            & 2287 & 112 & 9
            & 2 & 2
            & 13m43.7s & Polynomial
            & Unknown & Unknown 
            \\
        \hline
        Conjunction 1
            & 21247 & 81 & 1 
            & 3 & 2 
            & 20m41.35s & Conjunction
            & 0.01s & 3.16s
            \\
        \hline
    \end{tabular}
    \end{adjustbox}
    \end{center}
    % \end{adjustwidth}
    % \end{minipage}
    \end{center}
    \caption{Experiment Results}
    \label{tab:experiments}
\end{table*}

In this work, we implement our invariant inference framework into a tool called \textsc{Zilu}, 
written in C++ and shell code. 
\textsc{Zilu} uses GSL for selective sampling, LibSVM for machine learning, 
KLEE for concolic testing and Z3 for constraint solving. 
In our experimental evaluation, 
we test \textsc{Zilu} with \LL{Number} loop invariant benchmarks 
in the following form, where $\mathit{Body}$ can have nested loops and conditional choices. 
\[
    \{ \mathit{Pre} \} \mathit{while}(\mathit{Cond}) \{ \mathit{Body} \} \{ \mathit{Post} \}
\]
\LL{Introduce the sources of the benchmark.}
All benchmarks are available from~\cite{zilu}. 

The parameters chosen in our experimental evaluation can be elaborated as follows. 
In the \emph{Sampling} stage, 
the values of all of the program input variables in the random sampling 
and the chosen variables in the selective sampling 
follow the universal distribution over the range of $[-200, 200]$. 
In the \emph{Classification} stage, 
the accuracy of SVM linear learning are set to its maximum value 
in order to generate a absolutely correct classifier if it exists. 
In the \emph{Verification} stage, 
Z3 solver uses `integer' as the type of program variables. 

To evaluate the effectiveness of \textsc{Zilu}, 
we compared it with two available state-of-the-art invariant inference tools: 
Interproc~\cite{cite} and CAPChecker~\cite{cite}, 
which correspond to two different invariant generation methods. 
Interproc is based on abstract interpretation. 
In the experiment, Interproc uses its most expressive abstract domain, i.e., 
the reduced product of polyhedra and linear congruences abstraction. 
Similar to \textsc{Zilu}, Interproc explicitly labels the loop invariants in the loop program. 
We thus can manually check their correctness
and compare them with the invariants generated by our tool \textsc{Zilu}. 
On the other hand, CPACheck (formerly named after BLAST~\cite{cite}) is a software verification tool 
based on the framework of configurable program analysis~\cite{cite}. 
In the experiment, we ask it to generate loop invariant for program predicate abstraction. 
Since CPAChecker functions by proving the program correctness, 
we insert an error branch after each loop program and check for the reachability of the error. 

We present the experiment results in Table~\ref{tab:experiments}. 
Since our invariant reference method has random factors introduced by the sampling sources, 
the presented results are those with median running time in $10$ times of invariant reference process. 
All of the experiments are conducted using x86\_64 Ubuntu 14.04 (kernel 3.13.0-85-generic) 
with 2.3 GHz Intel Core i5 and 4G 1333MHz DDR3. 
In Table~\ref{tab:experiments}, the second column to the seventh column correspond to 
invariant generation details from \textsc{Zilu}. 
`$\sharp$Samples' represents the number of samples generated in the experiment, 
including those from random sampling, selective sampling and counter-example sampling. 
\LL{I need more information on the percentage of the samples. }
`$\sharp$Invariants' stands the numbers of invariants generated by SVM, 
and `$\sharp$Iterations' represents the number of invariant candidates. 
Notice that an invariant generated by SVM becomes an invariant candidate 
when it converges to two previously generated invariants from SVM in one iteration process. 
`$\sharp$Traces' represents the number of loop body traces produced by KLEE. 
and `$\sharp$Variables' represents the number of program variables. 
% In general, when numbers of traces and variables increase in a program,
% the invariant inference difficulty increases.



% section evaluations (end)

