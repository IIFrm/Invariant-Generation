/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#include "assert.h"

typedef unsigned int size_t;
typedef unsigned short __u_short;
typedef long long __quad_t;
typedef unsigned long long __u_quad_t;
typedef __u_quad_t __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned int __nlink_t;
typedef long __off_t;
typedef __quad_t __off64_t;
typedef int __pid_t;
typedef long __time_t;
typedef long __suseconds_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef int __ssize_t;
typedef __u_short u_short;
typedef __ssize_t ssize_t;
typedef unsigned short u_int16_t;
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[15U * sizeof(int ) - 2U * sizeof(void *)] ;
};
typedef unsigned long reg_syntax_t;
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
typedef struct re_pattern_buffer regex_t;
typedef int regoff_t;
struct __anonstruct_regmatch_t_22 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
typedef struct __anonstruct_regmatch_t_22 regmatch_t;
struct event_base;
struct __anonstruct_ev_next_23 {
   struct event *tqe_next ;
   struct event **tqe_prev ;
};
struct __anonstruct_ev_active_next_24 {
   struct event *tqe_next ;
   struct event **tqe_prev ;
};
struct __anonstruct_ev_signal_next_25 {
   struct event *tqe_next ;
   struct event **tqe_prev ;
};
struct event {
   struct __anonstruct_ev_next_23 ev_next ;
   struct __anonstruct_ev_active_next_24 ev_active_next ;
   struct __anonstruct_ev_signal_next_25 ev_signal_next ;
   unsigned int min_heap_idx ;
   struct event_base *ev_base ;
   int ev_fd ;
   short ev_events ;
   short ev_ncalls ;
   short *ev_pncalls ;
   struct timeval ev_timeout ;
   int ev_pri ;
   void (*ev_callback)(int  , short  , void *arg ) ;
   void *ev_arg ;
   int ev_res ;
   int ev_flags ;
};
struct url {
   char *host ;
   char *file ;
   u_short port ;
};
struct __anonstruct_next_27 {
   struct uri_small *tqe_next ;
   struct uri_small **tqe_prev ;
};
struct uri_small {
   struct __anonstruct_next_27 next ;
   struct url url ;
   u_short depth ;
   u_short flags ;
   u_short retry ;
};
struct dns_entry;
struct uri {
   u_short depth ;
   u_short flags ;
   u_short retry ;
   int code ;
   int save_fd ;
   struct url url ;
   char *format ;
   ssize_t length ;
   char *header ;
   size_t hdlen ;
   char *body ;
   size_t bdmemlen ;
   size_t bdread ;
   size_t bdlen ;
   struct dns_entry *dns ;
   int fd ;
   struct event ev ;
};
struct uri_list {
   struct uri_small *tqh_first ;
   struct uri_small **tqh_last ;
};
struct __anonstruct_next_29 {
   struct html_cb *tqe_next ;
   struct html_cb **tqe_prev ;
};
struct html_cb {
   struct __anonstruct_next_29 next ;
   char *name ;
   void (*cb)(void * , char * , char ** ) ;
};
struct cb_list {
   struct html_cb *tqh_first ;
   struct html_cb **tqh_last ;
};
struct html_parse {
   struct cb_list cbqueue ;
   char *base ;
   void *data ;
};
struct __anonstruct_next_30 {
   struct dns_entry *tqe_next ;
   struct dns_entry **tqe_prev ;
};
struct __anonstruct_wait_next_31 {
   struct dns_entry *tqe_next ;
   struct dns_entry **tqe_prev ;
};
struct __anonstruct_splay_next_32 {
   struct dns_entry *spe_left ;
   struct dns_entry *spe_right ;
};
struct addrinfo;
struct dns_entry {
   struct __anonstruct_next_30 next ;
   struct __anonstruct_wait_next_31 wait_next ;
   struct __anonstruct_splay_next_32 splay_next ;
   struct timeval creat ;
   struct timeval access ;
   int retries ;
   u_int16_t flags ;
   short ref ;
   char *name ;
   struct addrinfo *ai ;
   void (*cb)(struct addrinfo * , struct dns_entry * , void * ) ;
   void *cbarg ;
   int depth ;
   struct uri_list uriqueue ;
   struct uri_list mediaqueue ;
};
typedef unsigned char __u_char;
typedef unsigned int __socklen_t;
typedef __u_char u_char;
typedef __time_t time_t;
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
typedef struct timezone * __restrict  __timezone_ptr_t;
typedef __socklen_t socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
typedef void (*__sighandler_t)(int  );
struct header {
   char *name ;
   char **where ;
};
struct __anonstruct_next_53 {
   struct dispatch *tqe_next ;
   struct dispatch **tqe_prev ;
};
struct dispatch {
   struct __anonstruct_next_53 next ;
   char *type ;
   int (*cb)(struct uri * ) ;
};
struct __anonstruct_robot_next_54 {
   struct http_robots *tqe_next ;
   struct http_robots **tqe_prev ;
};
struct __anonstruct_splay_next_55 {
   struct http_robots *spe_left ;
   struct http_robots *spe_right ;
};
struct http_robots {
   struct __anonstruct_robot_next_54 robot_next ;
   struct __anonstruct_splay_next_55 splay_next ;
   char **dislist ;
   int flags ;
   char *host ;
   u_short port ;
};
struct dns_list {
   struct dns_entry *tqh_first ;
   struct dns_entry **tqh_last ;
};
struct dispatch_list {
   struct dispatch *tqh_first ;
   struct dispatch **tqh_last ;
};
struct stats {
   size_t bodybytes ;
   size_t headerbytes ;
   size_t gets ;
   size_t heads ;
   time_t start ;
   size_t fifosize ;
   size_t maxsize ;
};
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef uint16_t in_port_t;
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
typedef unsigned int __u_int;
typedef __u_int u_int;
typedef unsigned int u_int32_t;
struct __anonstruct_DBT_16 {
   void *data ;
   size_t size ;
};
typedef struct __anonstruct_DBT_16 DBT;
enum __anonenum_DBTYPE_17 {
    DB_BTREE = 0,
    DB_HASH = 1,
    DB_RECNO = 2
} ;
typedef enum __anonenum_DBTYPE_17 DBTYPE;
struct __db {
   DBTYPE type ;
   int (*close)(struct __db * ) ;
   int (*del)(struct __db  const  * , DBT const   * , u_int  ) ;
   int (*get)(struct __db  const  * , DBT const   * , DBT * , u_int  ) ;
   int (*put)(struct __db  const  * , DBT * , DBT const   * , u_int  ) ;
   int (*seq)(struct __db  const  * , DBT * , DBT * , u_int  ) ;
   int (*sync)(struct __db  const  * , u_int  ) ;
   void *internal ;
   int (*fd)(struct __db  const  * ) ;
};
typedef struct __db DB;
struct __anonstruct_BTREEINFO_18 {
   u_int32_t flags ;
   u_int32_t cachesize ;
   u_int32_t maxkeypage ;
   u_int32_t minkeypage ;
   u_int32_t psize ;
   int (*compare)(DBT const   * , DBT const   * ) ;
   size_t (*prefix)(DBT const   * , DBT const   * ) ;
   int lorder ;
};
typedef struct __anonstruct_BTREEINFO_18 BTREEINFO;
typedef unsigned long uint32;
struct MD5Context {
   uint32 buf[4] ;
   uint32 bits[2] ;
   unsigned char in[64] ;
};
typedef struct MD5Context MD5_CTX;
typedef __mode_t mode_t;
typedef unsigned int __uint32_t;
typedef __pid_t pid_t;
struct sockaddr_storage {
   sa_family_t ss_family ;
   __uint32_t __ss_align ;
   char __ss_padding[128U - 2U * sizeof(__uint32_t )] ;
};
struct dns_child {
   pid_t pid ;
   struct dns_entry *current ;
   int waits ;
   struct event ev_read ;
   struct event ev_write ;
   int cmd_write ;
   int res_read ;
   struct dns_list waitqueue ;
};
struct stats___0 {
   int hits ;
   int replacements ;
   int iterations ;
   int calls ;
};
struct tree {
   struct dns_entry *sph_root ;
};
struct dns_transport {
   struct addrinfo ai ;
   struct sockaddr_storage dns_addr ;
};
typedef __off_t off_t;
typedef unsigned char u_int8_t;
struct __anonstruct_link_22 {
   struct conf_list_node *tqe_next ;
   struct conf_list_node **tqe_prev ;
};
struct conf_list_node {
   struct __anonstruct_link_22 link ;
   char *field ;
};
struct conf_list_fields_head {
   struct conf_list_node *tqh_first ;
   struct conf_list_node **tqh_last ;
};
struct conf_list {
   int cnt ;
   struct conf_list_fields_head fields ;
};
struct __anonstruct_link_23 {
   struct conf_trans *tqe_next ;
   struct conf_trans **tqe_prev ;
};
enum conf_op {
    CONF_SET = 0,
    CONF_REMOVE = 1,
    CONF_REMOVE_SECTION = 2
} ;
struct conf_trans {
   struct __anonstruct_link_23 link ;
   int trans ;
   enum conf_op op ;
   char *section ;
   char *tag ;
   char *value ;
   int override ;
   int is_default ;
};
struct conf_trans_head {
   struct conf_trans *tqh_first ;
   struct conf_trans **tqh_last ;
};
struct __anonstruct_link_24 {
   struct conf_binding *le_next ;
   struct conf_binding **le_prev ;
};
struct conf_binding {
   struct __anonstruct_link_24 link ;
   char *section ;
   char *tag ;
   char *value ;
   int is_default ;
};
struct conf_bindings {
   struct conf_binding *lh_first ;
};
struct dumper {
   char *s ;
   char *v ;
   struct dumper *next ;
};
struct rtree {
   struct http_robots *sph_root ;
};
struct stats___1 {
   size_t robotfiles ;
   size_t matches ;
   size_t rejects ;
   size_t replacements ;
   size_t calls ;
   size_t iterations ;
};
struct robots_list {
   struct http_robots *tqh_first ;
   struct http_robots **tqh_last ;
};
#pragma merger(0,"/tmp/cil-sejcHktC.i","-Wall")
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) double strtod(char const   * __restrict  __nptr ,
                                                   char ** __restrict  __endptr )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern struct _IO_FILE *stdin ;
extern struct _IO_FILE *stdout ;
extern struct _IO_FILE *stderr ;
extern  __attribute__((__nothrow__)) int setvbuf(FILE * __restrict  __stream , char * __restrict  __buf ,
                                                 int __modes , size_t __n ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
extern void err(int eval , char const   *fmt  , ...) ;
extern void errx(int eval , char const   *fmt  , ...) ;
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type )  __attribute__((__nonnull__(1))) ;
extern int close(int __fd ) ;
/* AR: workaround to create a non-empty points-to set in Ptranal */
/* Replacing 
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
*/
ssize_t read(int __fd , void *__buf , size_t __nbytes ) {}
ssize_t write(int __fd , void const   *__buf , size_t __n ) {}

extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
extern  __attribute__((__nothrow__)) int execlp(char const   *__file , char const   *__arg 
                                                , ...)  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
extern char *optarg ;
extern int optind ;
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
extern struct event_base *event_init(void) ;
extern int event_dispatch(void) ;
int http_init(char *filename ) ;
int http_add(u_short type , char *url , u_short depth ) ;
int http_setuseragent(char *name ) ;
int http_postevent(void) ;
int http_restore_state(char *filename ) ;
int http_register_dispatch(char *type , int (*cb)(struct uri * ) ) ;
int http_mark_seen(char *line ) ;
char *http_basename(struct uri *uri ) ;
char *http_make_uri(char *base , char *rel ) ;
char *http_make_url(struct url *url ) ;
void http_print_stats(void) ;
struct html_parse *html_newparser(void) ;
int html_parser(struct html_parse *parser___0 , char *body___0 , size_t len ) ;
void html_freeparser(struct html_parse *p ) ;
int html_register_cb(struct html_parse *p , char *name , void (*callback)(void * ,
                                                                          char * ,
                                                                          char ** ) ) ;
char **html_attr_find(char **attr , char *name ) ;
void db_setup(char *file___0 ) ;
void db_close(void) ;
int isMedia(char *name ) ;
char *construct_path(char *uri , int mkdir___0 ) ;
void dns_init(void) ;
void dns_end(void) ;
void dns_print_stats(void) ;
int conf_get_num(char *section___0 , char *tag , int def ) ;
char *conf_get_str(char *section___0 , char *tag ) ;
void conf_init(void) ;
void usage(void) ;
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n ) ;
int url_permitted(char *url ) ;
int img_permitted(char *url ) ;
int image_saver(struct uri *uri ) ;
char *progname  ;
struct html_parse *parser  ;
regex_t reurlinc  ;
regex_t reurlexcl  ;
regex_t reimginc  ;
regex_t reimgexcl  ;
char *saveimgdir  ;
struct timeval tv_timeout  ;
int maxdepth  =    0;
int media_minlen  =    20000;
int media_maxlen  =    400000;
int extmatchw  =    -1;
int extmatchr  =    -1;
int debug  =    1;
void usage(void) 
{ 

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: [-u urlincl] [-e urlexcl] [-i imgincl] [-d dir] [-m depth] <url> ...\n\t for documentation of all options consult the man page\n",
          progname);
  return;
}
}
int url_permitted(char *url ) 
{ size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char ch ;
  size_t tmp___3 ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;
  ssize_t tmp___6 ;

  {
  tmp = strlen("http://");
  tmp___0 = strncasecmp((char const   *)url, "http://", tmp);
  if (tmp___0) {
    return (0);
  } else {

  }
  tmp___1 = regexec((regex_t const   * __restrict  )(& reurlinc), (char const   * __restrict  )url,
                    0U, (regmatch_t * __restrict  )((void *)0), 0);
  if (tmp___1 != 0) {
    return (0);
  } else {

  }
  tmp___2 = regexec((regex_t const   * __restrict  )(& reurlexcl), (char const   * __restrict  )url,
                    0U, (regmatch_t * __restrict  )((void *)0), 0);
  if (tmp___2 == 0) {
    return (0);
  } else {

  }
  if (extmatchw != -1) {
    tmp___3 = strlen((char const   *)url);
    tmp___4 = atomicio((ssize_t (*)())(& write), extmatchw, (void *)url, tmp___3);
    if (tmp___4 == -1) {
      err(1, "write");
    } else {

    }
    tmp___5 = atomicio((ssize_t (*)())(& write), extmatchw, (void *)"\n", 1U);
    if (tmp___5 == -1) {
      err(1, "write");
    } else {

    }
    tmp___6 = atomicio((ssize_t (*)())(& read), extmatchr, (void *)(& ch), 1U);
    if (tmp___6 == -1) {
      err(1, "read");
    } else {

    }
    if ((int )ch != 121) {
      return (0);
    } else {

    }
  } else {

  }
  return (1);
}
}
int img_permitted(char *url ) 
{ size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = strlen("http://");
  tmp___0 = strncasecmp((char const   *)url, "http://", tmp);
  if (tmp___0) {
    return (0);
  } else {

  }
  tmp___1 = regexec((regex_t const   * __restrict  )(& reimginc), (char const   * __restrict  )url,
                    0U, (regmatch_t * __restrict  )((void *)0), 0);
  if (tmp___1 != 0) {
    return (0);
  } else {

  }
  tmp___2 = regexec((regex_t const   * __restrict  )(& reimgexcl), (char const   * __restrict  )url,
                    0U, (regmatch_t * __restrict  )((void *)0), 0);
  if (tmp___2 == 0) {
    return (0);
  } else {

  }
  return (1);
}
}
int image_saver(struct uri *uri ) 
{ struct stat sb ;
  char *path___0 ;
  char tmp[128] ;
  char *p ;
  char *url ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int minlen ;
  int maxlen ;
  int tmp___3 ;
  ssize_t tmp___4 ;

  {
  p = (char *)"";
  url = http_make_url(& uri->url);
  if (uri->save_fd == -1) {
    tmp___0 = img_permitted(url);
    if (tmp___0) {

    } else {
      return (-1);
    }
  } else {

  }
  if (uri->length != -1) {
    if (uri->bdlen != (size_t )uri->length) {
      snprintf((char * __restrict  )(tmp), sizeof(tmp), (char const   * __restrict  )" (%4.1f%%/%d)",
               ((float )uri->bdlen / (float )uri->length) * (float )100, uri->length);
      p = tmp;
    } else {

    }
  } else {

  }
  if ((int )uri->flags & 1) {
    tmp___1 = (char const   *)p;
  } else {
    tmp___1 = "";
  }
  if ((int )uri->flags & 1) {
    tmp___2 = "GET";
  } else {
    tmp___2 = "HEAD";
  }
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%s %s%s\n", tmp___2,
          url, tmp___1);
  if ((int )uri->flags & 2) {
    if ((unsigned int )uri->format == (unsigned int )((void *)0)) {
      minlen = media_minlen;
      maxlen = media_maxlen;
    } else {
      minlen = conf_get_num(uri->format, (char *)"Min-Length", media_minlen);
      maxlen = conf_get_num(uri->format, (char *)"Max-Length", media_maxlen);
    }
    if (minlen != -1) {
      if (uri->length < minlen) {
        return (-1);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if (maxlen != -1) {
        if (uri->length > maxlen) {
          return (-1);
        } else {

        }
      } else {

      }
    }
    http_add((unsigned short)1, url, uri->depth);
    return (0);
  } else {

  }
  path___0 = construct_path(url, 1);
  if ((unsigned int )path___0 == (unsigned int )((void *)0)) {
    return (-1);
  } else {

  }
  tmp___3 = stat((char const   * __restrict  )path___0, (struct stat * __restrict  )(& sb));
  if (tmp___3 != -1) {
    if (sb.st_size >= (__off_t )uri->length) {
      return (-1);
    } else {

    }
  } else {

  }
  if (uri->save_fd == -1) {
    uri->save_fd = open((char const   *)path___0, 577, 420);
    if (uri->save_fd == -1) {
      return (-1);
    } else {

    }
  } else {

  }
  tmp___4 = atomicio((ssize_t (*)())(& write), uri->save_fd, (void *)uri->body, uri->bdread);
  if (tmp___4 == -1) {
    return (-1);
  } else {

  }
  uri->bdread = 0U;
  return (0);
}
}
void http_dealimage(char *url , u_short depth ) 
{ char *path___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = img_permitted(url);
  if (tmp) {

  } else {
    if (debug >= 3) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Reject: %s\n",
              url);
    } else {

    }
    return;
  }
  path___0 = construct_path(url, 0);
  if ((unsigned int )path___0 == (unsigned int )((void *)0)) {
    return;
  } else {

  }
  tmp___0 = access((char const   *)path___0, 0);
  if (tmp___0 != -1) {
    return;
  } else {

  }
  tmp___1 = http_mark_seen(url);
  if (tmp___1 != 0) {
    return;
  } else {

  }
  http_add((unsigned short)2, url, depth);
  return;
}
}
void html_foundimage(void *arg , char *el , char **attr ) 
{ struct uri *uri ;
  char *base ;
  char *normal___1 ;
  int tmp ;
  int tmp___0 ;

  {
  uri = (struct uri *)arg;
  tmp___0 = strcasecmp((char const   *)el, "img");
  if (tmp___0) {
    tmp = strcasecmp((char const   *)el, "body");
    if (tmp) {

    } else {
      attr = html_attr_find(attr, (char *)"background");
    }
  } else {
    attr = html_attr_find(attr, (char *)"src");
  }
  if ((unsigned int )*attr == (unsigned int )((void *)0)) {
    return;
  } else {

  }
  base = http_basename(uri);
  if ((unsigned int )base == (unsigned int )((void *)0)) {
    return;
  } else {

  }
  normal___1 = http_make_uri(base, *(attr + 1));
  if ((unsigned int )normal___1 == (unsigned int )((void *)0)) {
    if (debug >= 3) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed on %s and %s\n",
              base, *(attr + 1));
    } else {

    }
    return;
  } else {

  }
  http_dealimage(normal___1, (unsigned short )((int )uri->depth + 1));
  return;
}
}
void html_foundanchor(void *arg , char *el , char **attr ) 
{ struct uri *uri ;
  char *base ;
  char *normal___1 ;
  char **p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  uri = (struct uri *)arg;
  tmp___4 = strcasecmp((char const   *)el, "a");
  if (tmp___4) {
    tmp___3 = strcasecmp((char const   *)el, "frame");
    if (tmp___3) {
      tmp___2 = strcasecmp((char const   *)el, "iframe");
      if (tmp___2) {
        tmp___1 = strcasecmp((char const   *)el, "area");
        if (tmp___1) {
          tmp___0 = strcasecmp((char const   *)el, "base");
          if (tmp___0) {
            tmp = strcasecmp((char const   *)el, "link");
            if (tmp) {
              return;
            } else {
              p = html_attr_find(attr, (char *)"href");
              if ((unsigned int )*p != (unsigned int )((void *)0)) {
                attr = p;
              } else {
                attr = html_attr_find(attr, (char *)"rel");
              }
            }
          } else {
            attr = html_attr_find(attr, (char *)"link");
          }
        } else {
          attr = html_attr_find(attr, (char *)"href");
        }
      } else {
        attr = html_attr_find(attr, (char *)"src");
      }
    } else {
      attr = html_attr_find(attr, (char *)"src");
    }
  } else {
    attr = html_attr_find(attr, (char *)"href");
  }
  if ((unsigned int )*attr == (unsigned int )((void *)0)) {
    return;
  } else {

  }
  base = http_basename(uri);
  if ((unsigned int )base == (unsigned int )((void *)0)) {
    return;
  } else {

  }
  normal___1 = http_make_uri(base, *(attr + 1));
  if ((unsigned int )normal___1 == (unsigned int )((void *)0)) {
    if (debug >= 3) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed on %s and %s\n",
              base, *(attr + 1));
    } else {

    }
    return;
  } else {

  }
  tmp___5 = isMedia(normal___1);
  if (tmp___5) {
    http_dealimage(normal___1, (unsigned short )((int )uri->depth + 1));
    return;
  } else {

  }
  if (maxdepth != -1) {
    if ((int )uri->depth + 1 > maxdepth) {
      if (debug >= 2) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Max depth reached: %s\n",
                normal___1);
      } else {

      }
      return;
    } else {

    }
  } else {

  }
  tmp___6 = url_permitted(normal___1);
  if (tmp___6) {

  } else {
    if (debug >= 3) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Reject: %s\n",
              normal___1);
    } else {

    }
    return;
  }
  tmp___7 = http_mark_seen(normal___1);
  if (tmp___7 != 0) {
    return;
  } else {

  }
  http_add((unsigned short)1, normal___1, (unsigned short )((int )uri->depth + 1));
  return;
}
}
int html_follower(struct uri *uri ) 
{ char const   *tmp ;

  {
  if ((int )uri->flags & 1) {
    tmp = "GET";
  } else {
    tmp = "HEAD";
  }
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%s http://%s%s\n",
          tmp, uri->url.host, uri->url.file);
  if ((int )uri->flags & 2) {
    return (0);
  } else {

  }
  parser->data = (void *)uri;
  html_parser(parser, uri->body, uri->bdlen);
  return (0);
}
}
void http_moved(struct uri *uri , char *location ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = url_permitted(location);
  if (tmp) {

  } else {
    if (debug >= 3) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Reject: %s\n",
              location);
    } else {

    }
    return;
  }
  tmp___0 = http_mark_seen(location);
  if (tmp___0 != 0) {
    return;
  } else {

  }
  if ((int )uri->flags & 1) {
    tmp___1 = 1;
  } else {
    tmp___1 = 2;
  }
  http_add((unsigned short )tmp___1, location, uri->depth);
  return;
}
}
void external_filter(char *program ) 
{ int toext[2] ;
  int fromext[2] ;
  int res ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = pipe((int *)(toext));
  if (tmp == -1) {
    err(1, "pipe");
  } else {

  }
  tmp___0 = pipe((int *)(fromext));
  if (tmp___0 == -1) {
    err(1, "pipe");
  } else {

  }
  res = fork();
  if (res == -1) {
    err(1, "fork");
  } else {

  }
  if (res == 0) {
    tmp___1 = fileno(stdin);
    dup2(toext[0], tmp___1);
    close(toext[1]);
    tmp___2 = fileno(stdout);
    dup2(fromext[1], tmp___2);
    close(fromext[0]);
    tmp___3 = execlp((char const   *)program, (char const   *)program, (void *)0);
    if (tmp___3 == -1) {
      err(1, "execlp");
    } else {

    }
    exit(0);
  } else {

  }
  extmatchw = toext[1];
  extmatchr = fromext[0];
  close(toext[0]);
  close(fromext[1]);
  return;
}
}
int use_robots ;
int http_maxconnects ;
void (*http_movecb)(struct uri * , char * ) ;
int main(int argc , char **argv ) 
{ char *urlinclude ;
  char *urlexclude ;
  char *imginclude ;
  char *imgexclude ;
  char *agent ;
  char *state ;
  char *external ;
  char *resume ;
  int ch ;
  char *p ;
  char *tmp ;
  char *p___0 ;
  char *tmp___0 ;
  char *p___1 ;
  char *tmp___1 ;
  char *p___2 ;
  char *tmp___2 ;
  char *p___3 ;
  char *tmp___3 ;
  char *p___4 ;
  char *tmp___4 ;
  char *p___5 ;
  char *tmp___5 ;
  char *p___6 ;
  char *tmp___6 ;
  char *p___7 ;
  float val ;
  double tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;

  {
  urlinclude = (char *)"http://.*\\.citi\\.umich\\.edu";
  urlexclude = (char *)"\\.(ps|gz|c|h|tar|exe|doc|pdf|ppt|txt|diff)$";
  imginclude = (char *)"\\.(jpg|jpeg)";
  imgexclude = (char *)"thumbs\\.";
  agent = (char *)"crawl/0.4";
  state = (char *)"crawl.state";
  external = (char *)((void *)0);
  resume = (char *)((void *)0);
  progname = *(argv + 0);
  saveimgdir = (char *)".";
  tv_timeout.tv_usec = 0L;
  tv_timeout.tv_sec = tv_timeout.tv_usec;
  tv_timeout.tv_sec = 5L;
  conf_init();
  while (1) {
    tmp = conf_get_str((char *)"General", (char *)"Url-Include");
    p = tmp;
    if ((unsigned int )p != (unsigned int )((void *)0)) {
      urlinclude = p;
    } else {

    }
    break;
  }
  while (1) {
    tmp___0 = conf_get_str((char *)"General", (char *)"Url-Exclude");
    p___0 = tmp___0;
    if ((unsigned int )p___0 != (unsigned int )((void *)0)) {
      urlexclude = p___0;
    } else {

    }
    break;
  }
  while (1) {
    tmp___1 = conf_get_str((char *)"General", (char *)"Img-Include");
    p___1 = tmp___1;
    if ((unsigned int )p___1 != (unsigned int )((void *)0)) {
      imginclude = p___1;
    } else {

    }
    break;
  }
  while (1) {
    tmp___2 = conf_get_str((char *)"General", (char *)"Img-Exclude");
    p___2 = tmp___2;
    if ((unsigned int )p___2 != (unsigned int )((void *)0)) {
      imgexclude = p___2;
    } else {

    }
    break;
  }
  while (1) {
    tmp___3 = conf_get_str((char *)"General", (char *)"Img-Directory");
    p___3 = tmp___3;
    if ((unsigned int )p___3 != (unsigned int )((void *)0)) {
      saveimgdir = p___3;
    } else {

    }
    break;
  }
  while (1) {
    tmp___4 = conf_get_str((char *)"General", (char *)"External-Filter");
    p___4 = tmp___4;
    if ((unsigned int )p___4 != (unsigned int )((void *)0)) {
      external = p___4;
    } else {

    }
    break;
  }
  while (1) {
    tmp___5 = conf_get_str((char *)"HTTP", (char *)"Agent");
    p___5 = tmp___5;
    if ((unsigned int )p___5 != (unsigned int )((void *)0)) {
      agent = p___5;
    } else {

    }
    break;
  }
  while (1) {
    tmp___6 = conf_get_str((char *)"HTTP", (char *)"State-File");
    p___6 = tmp___6;
    if ((unsigned int )p___6 != (unsigned int )((void *)0)) {
      state = p___6;
    } else {

    }
    break;
  }
  use_robots = conf_get_num((char *)"HTTP", (char *)"Use-Robots", 1);
  http_maxconnects = conf_get_num((char *)"HTTP", (char *)"Connections", 20);
  maxdepth = conf_get_num((char *)"General", (char *)"Max-Depth", 0);
  media_minlen = conf_get_num((char *)"General", (char *)"Min-Length", 20000);
  media_maxlen = conf_get_num((char *)"General", (char *)"Max-Length", 400000);
  while (1) {
    ch = getopt(argc, (char * const  *)argv, "t:v:u:e:i:d:m:RA:E:I:c:");
    if (ch != -1) {

    } else {
      break;
    }
    switch (ch) {
    case 116: 
    tmp___7 = strtod((char const   * __restrict  )optarg, (char ** __restrict  )(& p___7));
    val = (float )tmp___7;
    if ((unsigned int )p___7 == (unsigned int )((void *)0)) {
      if ((int )*p___7 != 0) {
        usage();
        exit(1);
      } else {

      }
    } else {

    }
    tv_timeout.tv_sec = (long )val;
    tv_timeout.tv_usec = (long )((val - (float )((int )val)) * (float )1000000L);
    break;
    case 118: 
    debug = atoi((char const   *)optarg);
    break;
    case 99: 
    resume = optarg;
    break;
    case 117: 
    urlinclude = optarg;
    break;
    case 101: 
    urlexclude = optarg;
    break;
    case 105: 
    imginclude = optarg;
    break;
    case 73: 
    imgexclude = optarg;
    break;
    case 100: 
    saveimgdir = optarg;
    break;
    case 109: 
    maxdepth = atoi((char const   *)optarg);
    break;
    case 65: 
    agent = optarg;
    break;
    case 82: 
    use_robots = 0;
    break;
    case 69: 
    external = optarg;
    break;
    default: 
    usage();
    exit(1);
    }
  }
  argc = argc - optind;
  argv = argv + optind;
  if ((unsigned int )resume == (unsigned int )((void *)0)) {
    if (argc < 1) {
      usage();
      exit(1);
    } else {

    }
  } else {

  }
  tmp___8 = regcomp((regex_t * __restrict  )(& reurlinc), (char const   * __restrict  )urlinclude,
                    1 | (1 << 1));
  if (tmp___8 == -1) {
    errx(1, "Error compiling regexp: \'%s\'\n", urlinclude);
  } else {

  }
  tmp___9 = regcomp((regex_t * __restrict  )(& reurlexcl), (char const   * __restrict  )urlexclude,
                    1 | (1 << 1));
  if (tmp___9 == -1) {
    errx(1, "Error compiling regexp: \'%s\'\n", urlinclude);
  } else {

  }
  tmp___10 = regcomp((regex_t * __restrict  )(& reimginc), (char const   * __restrict  )imginclude,
                     1 | (1 << 1));
  if (tmp___10 == -1) {
    errx(1, "Error compiling regexp: \'%s\'\n", imginclude);
  } else {

  }
  tmp___11 = regcomp((regex_t * __restrict  )(& reimgexcl), (char const   * __restrict  )imgexclude,
                     1 | (1 << 1));
  if (tmp___11 == -1) {
    errx(1, "Error compiling regexp: \'%s\'\n", imgexclude);
  } else {

  }
  if ((unsigned int )external != (unsigned int )((void *)0)) {
    external_filter(external);
  } else {

  }
  db_setup((char *)"crawl.db");
  event_init();
  dns_init();
  http_init(state);
  if ((unsigned int )resume == (unsigned int )((void *)0)) {
    while (1) {
      if (argc) {

      } else {
        break;
      }
      tmp___12 = http_add((unsigned short)1, *(argv + 0), (unsigned short)0);
      if (tmp___12 != -1) {
        http_mark_seen(*(argv + 0));
      } else {

      }
      argc = argc - 1;
      argv = argv + 1;
      assert(argc > 0);
    }
  } else {
    tmp___13 = http_restore_state(resume);
    if (tmp___13 == -1) {
      exit(1);
    } else {

    }
  }
  while (1) {
    tmp___14 = http_postevent();
    if (tmp___14 != -1) {

    } else {
      break;
    }
  }
  tmp___15 = strlen((char const   *)agent);
  if (tmp___15) {
    http_setuseragent(agent);
  } else {

  }
  http_register_dispatch((char *)"text/html", & html_follower);
  http_register_dispatch((char *)"image/", & image_saver);
  http_register_dispatch((char *)"audio/", & image_saver);
  http_register_dispatch((char *)"video/", & image_saver);
  while (1) {
    http_movecb = (void (*)())(& http_moved);
    break;
  }
  parser = html_newparser();
  if ((unsigned int )parser == (unsigned int )((void *)0)) {
    return (-1);
  } else {

  }
  html_register_cb(parser, (char *)"img", & html_foundimage);
  html_register_cb(parser, (char *)"body", & html_foundimage);
  html_register_cb(parser, (char *)"a", & html_foundanchor);
  html_register_cb(parser, (char *)"frame", & html_foundanchor);
  html_register_cb(parser, (char *)"area", & html_foundanchor);
  html_register_cb(parser, (char *)"base", & html_foundanchor);
  html_register_cb(parser, (char *)"link", & html_foundanchor);
  setvbuf((FILE * __restrict  )stdout, (char * __restrict  )((void *)0), 2, 0U);
  event_dispatch();
  http_print_stats();
  dns_print_stats();
  dns_end();
  html_freeparser(parser);
  db_close();
  exit(0);
}
}
#pragma merger(0,"/tmp/cil-i0iY67BA.i","-Wall")
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz ) ;
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
extern void perror(char const   *__s ) ;
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s )  __attribute__((__nonnull__(1),
__malloc__)) ;
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) size_t strspn(char const   *__s , char const   *__accept )  __attribute__((__pure__,
__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern  __attribute__((__nothrow__)) char *strsep(char ** __restrict  __stringp ,
                                                  char const   * __restrict  __delim )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
extern void warn(char const   *fmt  , ...) ;
extern void warnx(char const   *fmt  , ...) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
size_t strlcat(char *dst , char const   *src , size_t siz ) ;
size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
extern void event_set(struct event * , int  , short  , void (*)(int  , short  , void * ) ,
                      void * ) ;
extern int event_add(struct event * , struct timeval * ) ;
extern int event_del(struct event * ) ;
extern int event_pending(struct event * , short  , struct timeval * ) ;
int connection_new(struct addrinfo *ai , u_short port ) ;
struct uri *uri_new(void) ;
void uri_free(struct uri *uri , int cleanconnect ) ;
int http_isrobotstxt(struct uri *uri ) ;
int http_newconnection(struct uri *uri , char *host___0 , u_short port ) ;
void http_fetch(struct uri *uri ) ;
int http_hostportfile(char *url , char **phost , u_short *pport , char **pfile ) ;
void http_parseheader(struct uri *uri ) ;
void http_readheader(int fd , short event , void *arg ) ;
void http_readbody(int fd , short event , void *arg ) ;
void http_dispatch(struct uri *uri , int mustfree ) ;
char *http_normalize_uri(char *uri ) ;
int db_seen(char *line ) ;
void http_robots_init(void) ;
int http_robots_allow(struct http_robots *htrobot , char *file___0 ) ;
void http_robots_response(struct uri *uri ) ;
struct http_robots *http_robots_find(char *host___0 , u_short port ) ;
int http_robots_get(char *host___0 , u_short port ) ;
void http_robots_print_stats(void) ;
int dns_ready(struct dns_entry *dns , struct timeval *tv , struct timeval *ready ,
              int max ) ;
int dns_resolve_cb(char *ip , u_short port , void (*cb)(struct addrinfo * , struct dns_entry * ,
                                                        void * ) , void *arg ) ;
void dns_ref(struct dns_entry *dns ) ;
void dns_unref(struct dns_entry *dns ) ;
struct dns_entry *dns_find(char *host___0 ) ;
void dns_setdepth(struct dns_entry *dns , int depth ) ;
void http_insert_order(struct uri_list *head , struct uri_small *uri ) ;
void http_connectioncb(int fd , short which , void *arg ) ;
int http_robotstxt(struct uri *uri ) ;
struct uri_list uriqueue  ;
struct uri_list mediaqueue  ;
struct dispatch_list dispatchqueue  ;
u_char body[32768]  ;
char *useragent  =    (char *)((void *)0);
char *rawname  =    (char *)((void *)0);
char *statefile  =    (char *)((void *)0);
void (*http_movecb)(struct uri * , char * )  =    (void (*)(struct uri * , char * ))((void *)0);
struct event ev_timeout  ;
int http_maxconnects  =    20;
int connections  ;
int dns_connections  ;
static int cacheable  ;
int use_robots  =    1;
int terminate  =    0;
static int in_httppostevent  ;
static struct stats http_stats  ;
struct uri *uri_new(void) 
{ struct uri *uri ;
  void *tmp ;

  {
  tmp = calloc(1U, sizeof(struct uri ));
  uri = (struct uri *)tmp;
  if ((unsigned int )uri == (unsigned int )((void *)0)) {
    return ((struct uri *)((void *)0));
  } else {

  }
  uri->fd = -1;
  uri->save_fd = -1;
  return (uri);
}
}
void uri_free(struct uri *uri , int cleanconnect ) 
{ int n ;
  int tmp ;

  {
  if (uri->ev.ev_flags & 128) {
    event_del(& uri->ev);
  } else {

  }
  if (use_robots) {
    http_robotstxt(uri);
  } else {

  }
  if (uri->fd != -1) {
    close(uri->fd);
  } else {

  }
  if (cleanconnect) {
    goto _L;
  } else {
    if (uri->fd != -1) {
      _L: /* CIL Label */ 
      n = 0;
      connections = connections - 1;
      while (1) {
        tmp = http_postevent();
        if (tmp != -1) {

        } else {
          break;
        }
        n = n + 1;
      }
    } else {

    }
  }
  if ((unsigned int )uri->dns != (unsigned int )((void *)0)) {
    dns_unref(uri->dns);
  } else {

  }
  if (uri->save_fd != -1) {
    close(uri->save_fd);
  } else {

  }
  if ((unsigned int )uri->url.host != (unsigned int )((void *)0)) {
    free((void *)uri->url.host);
  } else {

  }
  if ((unsigned int )uri->url.file != (unsigned int )((void *)0)) {
    free((void *)uri->url.file);
  } else {

  }
  if ((unsigned int )uri->header != (unsigned int )((void *)0)) {
    free((void *)uri->header);
  } else {

  }
  if ((unsigned int )uri->body != (unsigned int )((void *)0)) {
    free((void *)uri->body);
  } else {

  }
  if ((unsigned int )uri->format != (unsigned int )((void *)0)) {
    free((void *)uri->format);
  } else {

  }
  free((void *)uri);
  return;
}
}
struct uri_small *uri_small_new(void) 
{ struct uri_small *uri ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct uri_small ));
  uri = (struct uri_small *)tmp;
  memset((void *)(& uri->url), 0, sizeof(uri->url));
  uri->retry = (unsigned short)0;
  return (uri);
}
}
void uri_small_free(struct uri_small *uri ) 
{ 

  {
  if ((unsigned int )uri->url.host != (unsigned int )((void *)0)) {
    free((void *)uri->url.host);
  } else {

  }
  if ((unsigned int )uri->url.file != (unsigned int )((void *)0)) {
    free((void *)uri->url.file);
  } else {

  }
  free((void *)uri);
  return;
}
}
void terminate_handler(int sig ) 
{ int s ;
  int *tmp ;
  int *tmp___0 ;

  {
  tmp = __errno_location();
  s = *tmp;
  signal(2, (void (*)(int  ))1);
  signal(13, (void (*)(int  ))1);
  terminate = 1;
  tmp___0 = __errno_location();
  *tmp___0 = s;
  return;
}
}
void http_posteventcb(int fd , short which , void *arg ) 
{ int tmp ;

  {
  while (1) {
    tmp = http_postevent();
    if (tmp != -1) {

    } else {
      break;
    }
  }
  return;
}
}
int http_init(char *filename ) 
{ __sighandler_t tmp ;
  __sighandler_t tmp___0 ;

  {
  while (1) {
    uriqueue.tqh_first = (struct uri_small *)((void *)0);
    uriqueue.tqh_last = & uriqueue.tqh_first;
    break;
  }
  while (1) {
    mediaqueue.tqh_first = (struct uri_small *)((void *)0);
    mediaqueue.tqh_last = & mediaqueue.tqh_first;
    break;
  }
  while (1) {
    dispatchqueue.tqh_first = (struct dispatch *)((void *)0);
    dispatchqueue.tqh_last = & dispatchqueue.tqh_first;
    break;
  }
  event_set(& ev_timeout, -1, (short)0, & http_posteventcb, (void *)0);
  if (use_robots) {
    http_robots_init();
  } else {

  }
  connections = 0;
  memset((void *)(& http_stats), 0, sizeof(http_stats));
  http_stats.start = time((time_t *)((void *)0));
  if (filename) {
    statefile = strdup((char const   *)filename);
    if ((unsigned int )statefile == (unsigned int )((void *)0)) {
      perror("strdup");
      return (-1);
    } else {

    }
    tmp = signal(2, & terminate_handler);
    if ((unsigned int )tmp == (unsigned int )((void (*)(int  ))-1)) {
      perror("signal");
      return (-1);
    } else {

    }
    tmp___0 = signal(13, & terminate_handler);
    if ((unsigned int )tmp___0 == (unsigned int )((void (*)(int  ))-1)) {
      perror("signal");
      return (-1);
    } else {

    }
  } else {

  }
  return (0);
}
}
void http_print_stats(void) 
{ time_t spent ;
  size_t bytes ;
  time_t tmp ;

  {
  tmp = time((time_t *)((void *)0));
  spent = tmp - http_stats.start;
  bytes = http_stats.headerbytes + http_stats.bodybytes;
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%d GET for body %d Kbytes\n",
          http_stats.gets, http_stats.bodybytes / 1024U);
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%d HEAD for header %d Kbytes\n",
          http_stats.heads, http_stats.headerbytes / 1024U);
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"% 8.3f Requests/sec\n",
          (float )(http_stats.gets + http_stats.heads) / (float )spent);
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Throughput %f KBytes/sec\n",
          ((float )bytes / (float )1024) / (float )spent);
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Max fifo size: %d, %f Kbyte, current: %d/%d\n",
          http_stats.maxsize, ((float )http_stats.maxsize * (float )(sizeof(struct uri_small ) + 80U)) / (float )1024,
          http_stats.fifosize, connections);
  if (use_robots) {
    http_robots_print_stats();
  } else {

  }
  return;
}
}
int http_setuseragent(char *name ) 
{ char agent[1024] ;
  int tmp ;

  {
  if ((unsigned int )useragent != (unsigned int )((void *)0)) {
    free((void *)useragent);
  } else {

  }
  if ((unsigned int )rawname != (unsigned int )((void *)0)) {
    free((void *)rawname);
  } else {

  }
  rawname = strdup((char const   *)name);
  if ((unsigned int )rawname == (unsigned int )((void *)0)) {
    useragent = (char *)((void *)0);
    return (-1);
  } else {

  }
  snprintf((char * __restrict  )(agent), sizeof(agent), (char const   * __restrict  )"User-Agent: %s %s/%s\r\n",
           name, "libcrawl", "0.3");
  useragent = strdup((char const   *)(agent));
  if ((unsigned int )useragent != (unsigned int )((void *)0)) {
    tmp = 0;
  } else {
    tmp = -1;
  }
  return (tmp);
}
}
int http_register_dispatch(char *type , int (*cb)(struct uri * ) ) 
{ struct dispatch *dispatch ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct dispatch ));
  dispatch = (struct dispatch *)tmp;
  if ((unsigned int )dispatch == (unsigned int )((void *)0)) {
    warn("%s: malloc", "http_register_dispatch");
    return (-1);
  } else {

  }
  dispatch->type = type;
  dispatch->cb = cb;
  while (1) {
    dispatch->next.tqe_next = (struct dispatch *)((void *)0);
    dispatch->next.tqe_prev = dispatchqueue.tqh_last;
    *(dispatchqueue.tqh_last) = dispatch;
    dispatchqueue.tqh_last = & dispatch->next.tqe_next;
    break;
  }
  return (0);
}
}
void http_fetch(struct uri *uri ) 
{ char request[1024] ;
  char sport[32] ;
  struct timeval tv ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;

  {
  snprintf((char * __restrict  )(sport), sizeof(sport), (char const   * __restrict  )"%d",
           uri->url.port);
  if ((int )uri->url.port != 80) {
    tmp = (char const   *)(sport);
  } else {
    tmp = "";
  }
  if ((int )uri->url.port != 80) {
    tmp___0 = ":";
  } else {
    tmp___0 = "";
  }
  if ((unsigned int )useragent != (unsigned int )((void *)0)) {
    tmp___1 = (char const   *)useragent;
  } else {
    tmp___1 = "";
  }
  if ((int )uri->flags & 1) {
    tmp___2 = "GET";
  } else {
    tmp___2 = "HEAD";
  }
  snprintf((char * __restrict  )(request), sizeof(request), (char const   * __restrict  )"%s %s HTTP/1.0\r\n%sHost: %s%s%s\r\n\r\n",
           tmp___2, uri->url.file, tmp___1, uri->url.host, tmp___0, tmp);
  tmp___3 = strlen((char const   *)(request));
  atomicio((ssize_t (*)())(& write), uri->fd, (void *)(request), tmp___3);
  event_set(& uri->ev, uri->fd, (short)2, & http_readheader, (void *)uri);
  tv.tv_usec = 0L;
  tv.tv_sec = tv.tv_usec;
  tv.tv_sec = 180L;
  event_add(& uri->ev, & tv);
  return;
}
}
void http_collect(char *name , struct uri_list *dsthead , struct uri_list *srchead ) 
{ struct uri_small *tmp ;
  struct uri_small *next ;
  int tmp___0 ;

  {
  tmp = srchead->tqh_first;
  while (1) {
    if (tmp) {

    } else {
      break;
    }
    next = tmp->next.tqe_next;
    tmp___0 = strcasecmp((char const   *)name, (char const   *)tmp->url.host);
    if (tmp___0) {
      goto __Cont;
    } else {

    }
    while (1) {
      if ((unsigned int )tmp->next.tqe_next != (unsigned int )((void *)0)) {
        (tmp->next.tqe_next)->next.tqe_prev = tmp->next.tqe_prev;
      } else {
        srchead->tqh_last = tmp->next.tqe_prev;
      }
      *(tmp->next.tqe_prev) = tmp->next.tqe_next;
      break;
    }
    http_insert_order(dsthead, tmp);
    __Cont: /* CIL Label */ 
    tmp = next;
  }
  return;
}
}
void http_decollect(char *name , struct uri_list *srchead ) 
{ struct uri_small *tmp ;
  struct uri_small *next ;
  int tmp___0 ;

  {
  tmp = srchead->tqh_first;
  while (1) {
    if (tmp) {

    } else {
      break;
    }
    next = tmp->next.tqe_next;
    tmp___0 = strcasecmp((char const   *)name, (char const   *)tmp->url.host);
    if (tmp___0) {
      goto __Cont;
    } else {

    }
    while (1) {
      if ((unsigned int )tmp->next.tqe_next != (unsigned int )((void *)0)) {
        (tmp->next.tqe_next)->next.tqe_prev = tmp->next.tqe_prev;
      } else {
        srchead->tqh_last = tmp->next.tqe_prev;
      }
      *(tmp->next.tqe_prev) = tmp->next.tqe_next;
      break;
    }
    uri_small_free(tmp);
    __Cont: /* CIL Label */ 
    tmp = next;
  }
  return;
}
}
void http_dns_calcdepth(struct dns_entry *dns ) 
{ struct uri_small *suri ;
  int depth ;

  {
  depth = 0;
  suri = dns->mediaqueue.tqh_first;
  if ((unsigned int )suri != (unsigned int )((void *)0)) {
    if ((int )suri->depth > depth) {
      depth = (int )suri->depth;
    } else {

    }
  } else {

  }
  suri = dns->uriqueue.tqh_first;
  if ((unsigned int )suri != (unsigned int )((void *)0)) {
    if ((int )suri->depth > depth) {
      depth = (int )suri->depth;
    } else {

    }
  } else {

  }
  if (dns->depth != dns->depth) {
    dns_setdepth(dns, depth);
  } else {

  }
  return;
}
}
void http_newconnection_dnscb(struct addrinfo *ai , struct dns_entry *dns , void *arg ) 
{ struct uri *uri ;
  struct timeval tv ;
  int fd ;
  __suseconds_t tmp ;
  __time_t tmp___0 ;
  __suseconds_t tmp___1 ;

  {
  uri = (struct uri *)arg;
  dns_connections = dns_connections - 1;
  if ((unsigned int )dns != (unsigned int )((void *)0)) {
    if ((unsigned int )dns == (unsigned int )((struct dns_entry *)0)) {
      if (debug >= 1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: decollecting %s\n",
                "http_newconnection_dnscb", dns->name);
      } else {

      }
      http_decollect(dns->name, & dns->mediaqueue);
      http_decollect(dns->name, & dns->uriqueue);
      http_decollect(dns->name, & mediaqueue);
      http_decollect(dns->name, & uriqueue);
      goto fail;
    } else {
      if (dns->creat.tv_sec == dns->access.tv_sec) {
        tmp = dns->access.tv_usec;
        dns->creat.tv_usec = tmp;
        tmp___1 = tmp;
      } else {
        tmp___0 = dns->access.tv_sec;
        dns->creat.tv_sec = tmp___0;
        tmp___1 = tmp___0;
      }
      if (tmp___1) {
        http_collect(dns->name, & dns->mediaqueue, & mediaqueue);
        http_collect(dns->name, & dns->uriqueue, & uriqueue);
      } else {

      }
    }
    http_dns_calcdepth(dns);
  } else {

  }
  if ((unsigned int )ai == (unsigned int )((void *)0)) {
    goto fail;
  } else {

  }
  fd = connection_new(ai, uri->url.port);
  if (fd == -1) {
    goto fail;
  } else {

  }
  event_set(& uri->ev, fd, (short)4, & http_connectioncb, (void *)uri);
  tv.tv_usec = 0L;
  tv.tv_sec = tv.tv_usec;
  tv.tv_sec = 50L;
  event_add(& uri->ev, & tv);
  if ((unsigned int )uri->dns != (unsigned int )((void *)0)) {
    dns_unref(uri->dns);
  } else {

  }
  dns_ref(dns);
  uri->dns = dns;
  gettimeofday((struct timeval * __restrict  )(& dns->access), (struct timezone * __restrict  )((void *)0));
  while (1) {
    dns->access.tv_sec = dns->access.tv_sec + tv_timeout.tv_sec;
    dns->access.tv_usec = dns->access.tv_usec + tv_timeout.tv_usec;
    if (dns->access.tv_usec >= 1000000L) {
      dns->access.tv_sec = dns->access.tv_sec + 1L;
      dns->access.tv_usec = dns->access.tv_usec - 1000000L;
    } else {

    }
    break;
  }
  uri->fd = fd;
  return;
  fail: 
  uri_free(uri, 1);
  return;
}
}
int http_newconnection(struct uri *uri , char *host___0 , u_short port ) 
{ int res ;

  {
  connections = connections + 1;
  dns_connections = dns_connections + 1;
  res = dns_resolve_cb(host___0, port, & http_newconnection_dnscb, (void *)uri);
  if (res == -1) {
    dns_connections = dns_connections - 1;
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: http_newconnection(%s,%d) failed\n",
            "http_newconnection", host___0, port);
  } else {

  }
  return (res);
}
}
void http_connection_retry(struct uri *uri ) 
{ int tmp ;

  {
  uri->retry = (u_short )((int )uri->retry + 1);
  if ((int )uri->retry > 3) {
    goto fail;
  } else {

  }
  close(uri->fd);
  connections = connections - 1;
  tmp = http_newconnection(uri, uri->url.host, uri->url.port);
  if (tmp == -1) {
    goto fail;
  } else {

  }
  return;
  fail: 
  warnx("%s: failed retry: http://%s%s", "http_connection_retry", uri->url.host, uri->url.file);
  uri_free(uri, 1);
  return;
}
}
void http_connectioncb(int fd , short which , void *arg ) 
{ int error ;
  socklen_t errsz ;
  struct uri *uri ;
  int tmp ;
  char *tmp___0 ;

  {
  errsz = sizeof(error);
  uri = (struct uri *)arg;
  if ((int )which == 1) {
    goto retry;
  } else {

  }
  tmp = getsockopt(uri->fd, 1, 4, (void * __restrict  )(& error), (socklen_t * __restrict  )(& errsz));
  if (tmp == -1) {
    warn("%s: getsockopt for http://%s%s", "http_connectioncb", uri->url.host, uri->url.file);
    uri_free(uri, 1);
    return;
  } else {

  }
  if (error) {
    if (error == 110) {
      goto retry;
    } else {
      if (error == 111) {
        goto retry;
      } else {

      }
    }
    tmp___0 = strerror(error);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s failed: http://%s%s (%d)\n",
            "http_connectioncb", uri->url.host, uri->url.file, tmp___0, error);
    uri_free(uri, 1);
    return;
  } else {

  }
  http_fetch(uri);
  return;
  retry: 
  http_connection_retry(uri);
  return;
}
}
static char host[1024]  ;
static char file[1024]  ;
int http_hostportfile(char *url , char **phost , u_short *pport , char **pfile ) 
{ char *p ;
  char *p2 ;
  int len ;
  u_short port ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  tmp = strlen("http://");
  len = (int )tmp;
  tmp___0 = strncasecmp((char const   *)url, "http://", (unsigned int )len);
  if (tmp___0) {
    return (-1);
  } else {

  }
  url = url + len;
  tmp___1 = strlcpy(host, (char const   *)url, sizeof(host));
  if (tmp___1 >= sizeof(host)) {
    return (-1);
  } else {

  }
  p = strchr((char const   *)(host), '/');
  if ((unsigned int )p != (unsigned int )((void *)0)) {
    *p = (char )'\000';
    p2 = p + 1;
  } else {
    p2 = (char *)((void *)0);
  }
  if ((unsigned int )pfile != (unsigned int )((void *)0)) {
    if ((unsigned int )p2 == (unsigned int )((void *)0)) {
      p2 = (char *)"";
    } else {

    }
    snprintf((char * __restrict  )(file), sizeof(file), (char const   * __restrict  )"/%s",
             p2);
  } else {

  }
  p = strchr((char const   *)(host), ':');
  if ((unsigned int )p != (unsigned int )((void *)0)) {
    *p = (char )'\000';
    tmp___2 = atoi((char const   *)(p + 1));
    port = (unsigned short )tmp___2;
    if ((int )port == 0) {
      return (-1);
    } else {

    }
  } else {
    port = (unsigned short)80;
  }
  if ((unsigned int )phost != (unsigned int )((void *)0)) {
    *phost = host;
  } else {

  }
  if ((unsigned int )pport != (unsigned int )((void *)0)) {
    *pport = port;
  } else {

  }
  if ((unsigned int )pfile != (unsigned int )((void *)0)) {
    *pfile = file;
  } else {

  }
  return (0);
}
}
int http_restore_state(char *filename ) 
{ FILE *fp ;
  char line[2048] ;
  char *p ;
  char *p2 ;
  int i ;
  int type ;
  int depth ;
  int linenum ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  fp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
    err(1, "fopen");
  } else {

  }
  linenum = 1;
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Resuming from saved state...\n");
  cacheable = 1;
  while (1) {
    tmp___2 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )fp);
    if ((unsigned int )tmp___2 != (unsigned int )((void *)0)) {

    } else {
      break;
    }
    tmp = strlen((char const   *)(line));
    i = (int )(tmp - 1U);
    while (1) {
      if (i >= 0) {

      } else {
        break;
      }
      if ((int )line[i] == 13) {
        line[i] = (char )'\000';
      } else {
        if ((int )line[i] == 10) {
          line[i] = (char )'\000';
        } else {

        }
      }
      i = i - 1;
    }
    p2 = line;
    p = strsep((char ** __restrict  )(& p2), (char const   * __restrict  )" ");
    if ((int )*p != 103) {
      if ((int )*p != 104) {
        goto fail;
      } else {

      }
    } else {

    }
    if ((int )*p == 103) {
      type = 1;
    } else {
      type = 2;
    }
    p = strsep((char ** __restrict  )(& p2), (char const   * __restrict  )" ");
    if ((unsigned int )p == (unsigned int )((void *)0)) {
      goto fail;
    } else {
      if ((unsigned int )p2 == (unsigned int )((void *)0)) {
        goto fail;
      } else {
        depth = atoi((char const   *)p);
        if (depth < 0) {
          goto fail;
        } else {

        }
      }
    }
    tmp___0 = strlen("http://");
    tmp___1 = strncasecmp((char const   *)p2, "http://", tmp___0);
    if (tmp___1) {
      goto fail;
    } else {

    }
    http_add((unsigned short )type, p2, (unsigned short )depth);
    linenum = linenum + 1;
  }
  cacheable = 0;
  fclose(fp);
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Continuing with %d urls.\n",
          linenum - 1);
  return (0);
  fail: 
  fclose(fp);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Line %d in state file corrupt.\n",
          linenum);
  return (-1);
}
}
void http_savequeue(FILE *fp , struct uri_list *head , int *num ) 
{ struct uri_small *uri ;
  int linenum ;
  char *tmp ;
  int tmp___0 ;

  {
  linenum = *num;
  while (1) {
    uri = head->tqh_first;
    if ((unsigned int )uri != (unsigned int )((void *)0)) {

    } else {
      break;
    }
    while (1) {
      if ((unsigned int )uri->next.tqe_next != (unsigned int )((void *)0)) {
        (uri->next.tqe_next)->next.tqe_prev = uri->next.tqe_prev;
      } else {
        head->tqh_last = uri->next.tqe_prev;
      }
      *(uri->next.tqe_prev) = uri->next.tqe_next;
      break;
    }
    tmp = http_make_url(& uri->url);
    if ((int )uri->flags & 1) {
      tmp___0 = 'g';
    } else {
      tmp___0 = 'h';
    }
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%c %d %s\n", tmp___0,
            uri->depth, tmp);
    linenum = linenum + 1;
  }
  *num = linenum;
  return;
}
}
struct dns_list dnsqueue ;
void http_savestate(void) 
{ struct dns_entry *dns ;
  FILE *fpstate ;
  int linenum ;

  {
  fpstate = (FILE *)((void *)0);
  linenum = 0;
  event_del(& ev_timeout);
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Terminating...\n");
  fpstate = fopen((char const   * __restrict  )statefile, (char const   * __restrict  )"w");
  if ((unsigned int )fpstate == (unsigned int )((void *)0)) {
    err(1, "fopen");
  } else {

  }
  dns = dnsqueue.tqh_first;
  while (1) {
    if ((unsigned int )dns != (unsigned int )((void *)0)) {

    } else {
      break;
    }
    http_savequeue(fpstate, & dns->mediaqueue, & linenum);
    http_savequeue(fpstate, & dns->uriqueue, & linenum);
    dns = dns->next.tqe_next;
  }
  http_savequeue(fpstate, & mediaqueue, & linenum);
  http_savequeue(fpstate, & uriqueue, & linenum);
  fclose(fpstate);
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Terminated with %d saved urls.\n",
          linenum);
  return;
}
}
int http_robot_check(struct uri_list *head , struct uri_small *suri , char *host___0 ,
                     short port ) 
{ struct http_robots *htrobot ;
  int tmp ;
  int tmp___0 ;

  {
  htrobot = http_robots_find(host___0, (unsigned short )port);
  if ((unsigned int )htrobot == (unsigned int )((void *)0)) {
    tmp = http_robots_get(host___0, (unsigned short )port);
    if (tmp != -1) {
      return (2);
    } else {

    }
  } else {
    if (htrobot->flags & 1) {
      return (3);
    } else {

    }
    tmp___0 = http_robots_allow(htrobot, suri->url.file);
    if (tmp___0) {

    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: robots diallowed url: http://%s%s\n",
              "http_robot_check", suri->url.host, suri->url.file);
      while (1) {
        if ((unsigned int )suri->next.tqe_next != (unsigned int )((void *)0)) {
          (suri->next.tqe_next)->next.tqe_prev = suri->next.tqe_prev;
        } else {
          head->tqh_last = suri->next.tqe_prev;
        }
        *(suri->next.tqe_prev) = suri->next.tqe_next;
        break;
      }
      http_stats.fifosize = http_stats.fifosize - 1U;
      uri_small_free(suri);
      return (1);
    }
  }
  return (0);
}
}
int http_schedule(struct dns_entry *dns , struct uri_list *head ) 
{ struct uri *uri ;
  struct uri_small *suri ;
  struct uri_small *next ;
  int res ;
  int res___0 ;
  int tmp ;
  int tmp___0 ;

  {
  res = -1;
  uri = uri_new();
  if ((unsigned int )uri == (unsigned int )((void *)0)) {
    return (-1);
  } else {

  }
  suri = head->tqh_first;
  while (1) {
    if (suri) {

    } else {
      break;
    }
    next = suri->next.tqe_next;
    if ((unsigned int )dns == (unsigned int )((void *)0)) {
      if (dns_connections > http_maxconnects / 3) {
        return (-1);
      } else {
        if (dns_connections > 6) {
          return (-1);
        } else {

        }
      }
    } else {

    }
    if (use_robots) {
      tmp = http_robot_check(head, suri, suri->url.host, (short )suri->url.port);
      res___0 = tmp;
      switch (res___0) {
      case 2: 
      if (connections >= http_maxconnects) {
        res___0 = 0;
        goto out;
      } else {

      }
      case 3: 
      case 1: 
      goto __Cont;
      case 0: 
      break;
      }
    } else {

    }
    while (1) {
      if ((unsigned int )suri->next.tqe_next != (unsigned int )((void *)0)) {
        (suri->next.tqe_next)->next.tqe_prev = suri->next.tqe_prev;
      } else {
        head->tqh_last = suri->next.tqe_prev;
      }
      *(suri->next.tqe_prev) = suri->next.tqe_next;
      break;
    }
    http_stats.fifosize = http_stats.fifosize - 1U;
    uri->url = suri->url;
    uri->flags = suri->flags;
    uri->depth = suri->depth;
    suri->url.host = (char *)((void *)0);
    suri->url.file = (char *)((void *)0);
    tmp___0 = http_newconnection(uri, uri->url.host, uri->url.port);
    if (tmp___0 == -1) {
      connections = connections - 1;
      suri->url = uri->url;
      uri->url.host = (char *)((void *)0);
      uri->url.file = (char *)((void *)0);
      suri->retry = (u_short )((int )suri->retry + 1);
      if ((int )suri->retry >= 3) {
        uri_small_free(suri);
      } else {
        http_insert_order(head, suri);
        while (1) {
          http_stats.fifosize = http_stats.fifosize + 1U;
          if (http_stats.fifosize > http_stats.maxsize) {
            http_stats.maxsize = http_stats.fifosize;
          } else {

          }
          break;
        }
      }
      goto __Cont;
    } else {

    }
    break;
    __Cont: /* CIL Label */ 
    suri = next;
  }
  if ((unsigned int )suri == (unsigned int )((void *)0)) {
    goto out;
  } else {

  }
  uri_small_free(suri);
  return (0);
  out: 
  if ((unsigned int )uri != (unsigned int )((void *)0)) {
    uri_free(uri, 0);
  } else {

  }
  return (res);
}
}
int dns_schedule(int media ) 
{ struct uri_list *head ;
  struct uri_small *suri ;
  struct dns_entry *dns ;
  struct timeval now ;
  struct timeval tv_ready ;
  struct timeval tv_min ;
  int res ;
  int depth ;
  int tmp ;
  int tmp___0 ;
  struct uri_list *tmp___1 ;
  struct timeval tv ;
  int tmp___2 ;

  {
  res = -1;
  depth = 0;
  gettimeofday((struct timeval * __restrict  )(& now), (struct timezone * __restrict  )((void *)0));
  if (media) {
    head = & mediaqueue;
  } else {
    head = & uriqueue;
  }
  suri = head->tqh_first;
  if ((unsigned int )suri != (unsigned int )((void *)0)) {
    depth = (int )suri->depth;
  } else {

  }
  tv_min.tv_usec = 0L;
  tv_min.tv_sec = tv_min.tv_usec;
  dns = dnsqueue.tqh_first;
  while (1) {
    if ((unsigned int )dns != (unsigned int )((void *)0)) {

    } else {
      break;
    }
    if ((unsigned int )head != (unsigned int )((void *)0)) {
      if (dns->depth < depth) {
        res = http_schedule((struct dns_entry *)((void *)0), head);
        if (res != -1) {
          dns = (struct dns_entry *)((void *)0);
          break;
        } else {

        }
        head = (struct uri_list *)((void *)0);
      } else {

      }
    } else {

    }
    tmp___0 = dns_ready(dns, & now, & tv_ready, 3);
    if (tmp___0) {

    } else {
      if (tv_ready.tv_sec) {
        goto _L___0;
      } else {
        if (tv_ready.tv_usec) {
          _L___0: /* CIL Label */ 
          if (tv_min.tv_sec) {
            goto _L;
          } else {
            if (tv_min.tv_usec) {
              _L: /* CIL Label */ 
              if (tv_ready.tv_sec == tv_min.tv_sec) {
                tmp = tv_ready.tv_usec < tv_min.tv_usec;
              } else {
                tmp = tv_ready.tv_sec < tv_min.tv_sec;
              }
              if (tmp) {
                tv_min = tv_ready;
              } else {

              }
            } else {
              tv_min = tv_ready;
            }
          }
        } else {

        }
      }
      goto __Cont;
    }
    if (media) {
      tmp___1 = & dns->mediaqueue;
    } else {
      tmp___1 = & dns->uriqueue;
    }
    res = http_schedule(dns, tmp___1);
    if (res != -1) {
      break;
    } else {

    }
    __Cont: /* CIL Label */ 
    dns = dns->next.tqe_next;
  }
  if ((unsigned int )dns != (unsigned int )((void *)0)) {
    if (res != -1) {
      http_dns_calcdepth(dns);
      return (0);
    } else {

    }
  } else {
    if ((unsigned int )head != (unsigned int )((void *)0)) {
      res = http_schedule((struct dns_entry *)((void *)0), head);
    } else {

    }
  }
  if (res == -1) {
    if (tv_min.tv_sec) {
      goto _L___1;
    } else {
      if (tv_min.tv_usec) {
        _L___1: /* CIL Label */ 
        tmp___2 = event_pending(& ev_timeout, (short)1, (struct timeval *)((void *)0));
        if (tmp___2) {

        } else {
          while (1) {
            tv.tv_sec = tv_min.tv_sec - now.tv_sec;
            tv.tv_usec = tv_min.tv_usec - now.tv_usec;
            if (tv.tv_usec < 0L) {
              tv.tv_sec = tv.tv_sec - 1L;
              tv.tv_usec = tv.tv_usec + 1000000L;
            } else {

            }
            break;
          }
          event_add(& ev_timeout, & tv);
        }
      } else {

      }
    }
  } else {

  }
  return (res);
}
}
int http_postevent(void) 
{ int res ;

  {
  if (connections >= http_maxconnects) {
    if (debug >= 4) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %d >= http_maxconnects\n",
              "http_postevent", connections);
    } else {

    }
    return (-1);
  } else {

  }
  if (terminate) {
    if (connections == 0) {
      http_savestate();
      return (-1);
    } else {

    }
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Terminating: %3d(%3d) of %3d connections pending.\n",
            connections, dns_connections, http_maxconnects);
    return (-1);
  } else {

  }
  if (in_httppostevent) {
    return (-1);
  } else {

  }
  in_httppostevent = 1;
  event_del(& ev_timeout);
  res = dns_schedule(1);
  if (res == 0) {
    goto out;
  } else {

  }
  res = dns_schedule(0);
  out: 
  in_httppostevent = 0;
  return (res);
}
}
static struct uri_list *cache_head  ;
static struct uri_small *cache_uri  ;
static int cache_depth  ;
void http_insert_order(struct uri_list *head , struct uri_small *uri ) 
{ struct uri_small *tmp ;
  struct uri_small *tmp___0 ;

  {
  if (cacheable) {
    if ((unsigned int )cache_head == (unsigned int )head) {
      if ((int )uri->depth <= cache_depth) {
        tmp = cache_uri;
      } else {
        tmp = head->tqh_first;
      }
    } else {
      tmp = head->tqh_first;
    }
  } else {
    tmp = head->tqh_first;
  }
  while (1) {
    if (tmp) {

    } else {
      break;
    }
    if ((int )tmp->depth <= (int )uri->depth) {
      break;
    } else {

    }
    tmp = tmp->next.tqe_next;
  }
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
    while (1) {
      tmp___0 = head->tqh_first;
      uri->next.tqe_next = tmp___0;
      if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
        (head->tqh_first)->next.tqe_prev = & uri->next.tqe_next;
      } else {
        head->tqh_last = & uri->next.tqe_next;
      }
      head->tqh_first = uri;
      uri->next.tqe_prev = & head->tqh_first;
      break;
    }
  } else {
    while (1) {
      uri->next.tqe_prev = tmp->next.tqe_prev;
      uri->next.tqe_next = tmp;
      *(tmp->next.tqe_prev) = uri;
      tmp->next.tqe_prev = & uri->next.tqe_next;
      break;
    }
  }
  if (cacheable) {
    cache_head = head;
    cache_uri = uri;
    cache_depth = (int )uri->depth;
  } else {

  }
  return;
}
}
int http_add(u_short type , char *url , u_short depth ) 
{ struct uri_small *uri ;
  struct uri_list *head ;
  struct dns_entry *dns ;
  u_short port ;
  char *host___0 ;
  char *file___0 ;
  int tmp ;
  int tmp___1 ;
  int tmp___3 ;

  {
  tmp = http_hostportfile(url, & host___0, & port, & file___0);
  if (tmp == -1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: illegal url: %s\n",
            "http_add", url);
    return (-1);
  } else {

  }
  dns = dns_find(host___0);
  if ((unsigned int )dns != (unsigned int )((void *)0)) {
    if ((unsigned int )dns == (unsigned int )((struct dns_entry *)0)) {
      if (debug >= 1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: dropping %s on negative dns cache hit\n",
                "http_add", url);
      } else {

      }
      return (0);
    } else {

    }
  } else {

  }
  uri = uri_small_new();
  if ((unsigned int )uri == (unsigned int )((void *)0)) {
    warn("%s: malloc", "http_add");
    return (-1);
  } else {

  }
  uri->url.host = strdup((char const   *)host___0);
  uri->url.file = strdup((char const   *)file___0);
  uri->url.port = port;
  if ((unsigned int )uri->url.host == (unsigned int )((void *)0)) {
    warn("%s: malloc", "http_add");
    uri_small_free(uri);
    return (-1);
  } else {
    if ((unsigned int )uri->url.file == (unsigned int )((void *)0)) {
      warn("%s: malloc", "http_add");
      uri_small_free(uri);
      return (-1);
    } else {

    }
  }
  uri->flags = type;
  uri->depth = depth;
  if ((unsigned int )dns != (unsigned int )((void *)0)) {
    tmp___1 = isMedia(url);
    if (tmp___1) {
      head = & dns->mediaqueue;
    } else {
      head = & dns->uriqueue;
    }
  } else {
    tmp___3 = isMedia(url);
    if (tmp___3) {
      head = & mediaqueue;
    } else {
      head = & uriqueue;
    }
  }
  http_insert_order(head, uri);
  while (1) {
    http_stats.fifosize = http_stats.fifosize + 1U;
    if (http_stats.fifosize > http_stats.maxsize) {
      http_stats.maxsize = http_stats.fifosize;
    } else {

    }
    break;
  }
  return (0);
}
}
void http_readheader(int fd , short event , void *arg ) 
{ char line[2048] ;
  char *p ;
  ssize_t n ;
  ssize_t offset ;
  struct timeval tv ;
  struct uri *uri ;
  int *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
  uri = (struct uri *)arg;
  if ((int )event == 1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: timeout http://%s%s\n",
            "http_readheader", uri->url.host, uri->url.file);
    uri_free(uri, 1);
    return;
  } else {

  }
  n = read(uri->fd, (void *)(line), sizeof(line));
  if (n == -1) {
    tmp = __errno_location();
    if (*tmp == 4) {
      goto readmore;
    } else {
      tmp___0 = __errno_location();
      if (*tmp___0 == 11) {
        goto readmore;
      } else {

      }
    }
    warn("%s: read", "http_readheader");
    uri_free(uri, 1);
    return;
  } else {
    if (n == 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: finished read on http://%s%s?\n",
              "http_readheader", uri->url.host, uri->url.file);
      uri_free(uri, 1);
      return;
    } else {

    }
  }
  tmp___1 = realloc((void *)uri->header, (uri->hdlen + (size_t )n) + 1U);
  p = (char *)tmp___1;
  if ((unsigned int )p == (unsigned int )((void *)0)) {
    warn("%s: realloc", "http_readheader");
    uri_free(uri, 1);
    return;
  } else {

  }
  uri->header = p;
  memcpy((void * __restrict  )(uri->header + uri->hdlen), (void const   * __restrict  )(line),
         (unsigned int )n);
  uri->hdlen = uri->hdlen + (size_t )n;
  *(uri->header + uri->hdlen) = (char )'\000';
  p = strstr((char const   *)uri->header, "\r\n\r\n");
  if ((unsigned int )p == (unsigned int )((void *)0)) {
    goto readmore;
  } else {

  }
  tmp___2 = strlen("\r\n\r\n");
  offset = (p + tmp___2) - uri->header;
  if ((size_t )offset < uri->hdlen) {
    uri->bdlen = uri->hdlen - (size_t )offset;
    tmp___3 = malloc(uri->bdlen + 1U);
    uri->body = (char *)tmp___3;
    if ((unsigned int )uri->body == (unsigned int )((void *)0)) {
      warn("%s: malloc", "http_readheader");
      uri_free(uri, 1);
      return;
    } else {

    }
    memcpy((void * __restrict  )uri->body, (void const   * __restrict  )(uri->header + offset),
           uri->bdlen);
    *(uri->body + uri->bdlen) = (char )'\000';
    uri->hdlen = (unsigned int )offset;
    *(uri->header + offset) = (char )'\000';
  } else {

  }
  http_parseheader(uri);
  return;
  readmore: 
  tv.tv_usec = 0L;
  tv.tv_sec = tv.tv_usec;
  tv.tv_sec = 180L;
  event_add(& uri->ev, & tv);
  return;
}
}
void http_parseheader(struct uri *uri ) 
{ char *p ;
  char *end ;
  int major ;
  int minor ;
  int code ;
  char *type ;
  char *length ;
  char *location ;
  struct header parse[4] ;
  struct header *hdr ;
  struct timeval tv ;
  int tmp ;
  char *lend ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  struct dispatch *dispatch ;
  char *format ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t len ;
  u_char *p___0 ;
  void *tmp___9 ;

  {
  type = (char *)((void *)0);
  length = (char *)((void *)0);
  location = (char *)((void *)0);
  parse[0].name = (char *)"Content-Type: ";
  parse[0].where = & type;
  parse[1].name = (char *)"Content-Length: ";
  parse[1].where = & length;
  parse[2].name = (char *)"Location: ";
  parse[2].where = & location;
  parse[3].name = (char *)((void *)0);
  parse[3].where = (char **)((void *)0);
  tmp = sscanf((char const   * __restrict  )uri->header, (char const   * __restrict  )"HTTP/%d.%d %d",
               & major, & minor, & code);
  if (tmp != 3) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: illegal header in http://%s%s\n",
            "http_parseheader", uri->url.host, uri->url.file);
    uri_free(uri, 1);
    return;
  } else {
    if (major != 1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: illegal header in http://%s%s\n",
              "http_parseheader", uri->url.host, uri->url.file);
      uri_free(uri, 1);
      return;
    } else {
      if (minor != 0) {
        if (minor != 1) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: illegal header in http://%s%s\n",
                  "http_parseheader", uri->url.host, uri->url.file);
          uri_free(uri, 1);
          return;
        } else {

        }
      } else {

      }
    }
  }
  p = uri->header;
  end = p + uri->hdlen;
  while (1) {
    if ((unsigned int )p < (unsigned int )end) {

    } else {
      break;
    }
    lend = strstr((char const   *)p, "\r\n");
    if ((unsigned int )lend == (unsigned int )((void *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: illegal header in http://%s%s\n",
              "http_parseheader", uri->url.host, uri->url.file);
      uri_free(uri, 1);
      return;
    } else {

    }
    hdr = parse;
    while (1) {
      if (hdr->name) {

      } else {
        break;
      }
      tmp___1 = strlen((char const   *)hdr->name);
      tmp___2 = strncasecmp((char const   *)p, (char const   *)hdr->name, tmp___1);
      if (tmp___2 == 0) {
        tmp___0 = strlen((char const   *)hdr->name);
        *(hdr->where) = p + tmp___0;
        break;
      } else {

      }
      hdr = hdr + 1;
    }
    p = lend + 2;
  }
  if ((unsigned int )length == (unsigned int )((void *)0)) {
    uri->length = -1;
  } else {
    uri->length = atoi((char const   *)length);
  }
  if ((unsigned int )type != (unsigned int )((void *)0)) {
    end = strstr((char const   *)type, "\r\n");
    tmp___3 = malloc((unsigned int )((end - type) + 1));
    uri->format = (char *)tmp___3;
    if ((unsigned int )uri->format == (unsigned int )((void *)0)) {
      warn("%s: malloc", "http_parseheader");
      uri_free(uri, 1);
      return;
    } else {

    }
    memcpy((void * __restrict  )uri->format, (void const   * __restrict  )type, (unsigned int )(end - type));
    *(uri->format + (end - type)) = (char )'\000';
  } else {

  }
  uri->code = code;
  switch (code) {
  case 200: 
  break;
  case 302: 
  case 301: 
  if ((unsigned int )location == (unsigned int )((void *)0)) {
    goto error;
  } else {
    if ((unsigned int )http_movecb == (unsigned int )((void *)0)) {
      goto error;
    } else {
      if (use_robots) {
        tmp___4 = http_isrobotstxt(uri);
        if (tmp___4) {
          goto error;
        } else {

        }
      } else {

      }
    }
  }
  p = location;
  end = strstr((char const   *)p, "\r\n");
  tmp___5 = malloc((unsigned int )((end - p) + 1));
  location = (char *)tmp___5;
  if ((unsigned int )location == (unsigned int )((void *)0)) {
    warn("%s: malloc", "http_parseheader");
    uri_free(uri, 1);
    return;
  } else {

  }
  memcpy((void * __restrict  )location, (void const   * __restrict  )p, (unsigned int )(end - p));
  *(location + (end - p)) = (char )'\000';
  // AR: commenting out call through a function pointer
  //  (*http_movecb)(uri, location);
  // AR: replacing the pointer dereference by the corresponding function
  http_moved(uri, location);
  free((void *)location);
  uri_free(uri, 1);
  return;
  default: ;
  goto error;
  }
  if ((int )uri->flags & 2) {
    http_dispatch(uri, 1);
    return;
  } else {

  }
  if ((unsigned int )uri->format != (unsigned int )((void *)0)) {
    format = uri->format;
    if (use_robots) {
      tmp___6 = http_isrobotstxt(uri);
      if (tmp___6) {
        goto conturi;
      } else {

      }
    } else {

    }
    dispatch = dispatchqueue.tqh_first;
    while (1) {
      if ((unsigned int )dispatch != (unsigned int )((void *)0)) {

      } else {
        break;
      }
      tmp___7 = strlen((char const   *)dispatch->type);
      tmp___8 = strncasecmp((char const   *)format, (char const   *)dispatch->type,
                            tmp___7);
      if (tmp___8 == 0) {
        break;
      } else {

      }
      dispatch = dispatch->next.tqe_next;
    }
    if ((unsigned int )dispatch == (unsigned int )((void *)0)) {
      goto error;
    } else {

    }
  } else {

  }
  conturi: 
  if (uri->length != -1) {
    len = (unsigned int )uri->length;
    if (len > 131072U) {
      len = 131072U;
    } else {

    }
    tmp___9 = realloc((void *)uri->body, len + 1U);
    p___0 = (u_char *)tmp___9;
    if ((unsigned int )p___0 == (unsigned int )((void *)0)) {
      warn("%s: malloc", "http_parseheader");
      uri_free(uri, 1);
      return;
    } else {

    }
    uri->body = (char *)p___0;
    *(uri->body + len) = (char )'\000';
    uri->bdmemlen = len;
    uri->bdread = uri->bdlen;
  } else {

  }
  event_set(& uri->ev, uri->fd, (short)2, & http_readbody, (void *)uri);
  tv.tv_usec = 0L;
  tv.tv_sec = tv.tv_usec;
  tv.tv_sec = 180L;
  event_add(& uri->ev, & tv);
  return;
  error: 
  http_stats.headerbytes = http_stats.headerbytes + uri->hdlen;
  if (debug >= 1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: abort http://%s%s: %d\n",
            "http_parseheader", uri->url.host, uri->url.file, code);
  } else {

  }
  uri_free(uri, 1);
  return;
}
}
void http_readbody(int fd , short event , void *arg ) 
{ struct uri *uri ;
  struct timeval tv ;
  ssize_t n ;
  u_char *where ;
  ssize_t len ;
  int *tmp ;
  int *tmp___0 ;
  u_char *p ;
  void *tmp___1 ;

  {
  uri = (struct uri *)arg;
  if ((int )event == 1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: timeout http://%s%s\n",
            "http_readbody", uri->url.host, uri->url.file);
    uri_free(uri, 1);
    return;
  } else {

  }
  if (uri->length == -1) {
    where = body;
    len = (int )sizeof(body);
  } else {
    where = (u_char *)(uri->body + uri->bdread);
    len = (int )((size_t )uri->length - uri->bdlen);
    if ((size_t )len > uri->bdmemlen - uri->bdread) {
      len = (int )(uri->bdmemlen - uri->bdread);
    } else {

    }
  }
  n = read(uri->fd, (void *)where, (unsigned int )len);
  if (n == -1) {
    tmp = __errno_location();
    if (*tmp == 4) {
      goto readmore;
    } else {
      tmp___0 = __errno_location();
      if (*tmp___0 == 11) {
        goto readmore;
      } else {

      }
    }
    warn("%s: read", "http_readbody");
    uri_free(uri, 1);
    return;
  } else {
    if (n == 0) {
      if (uri->length != -1) {
        if ((size_t )uri->length != uri->bdlen) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: short read on http://%s%s\n",
                  "http_readbody", uri->url.host, uri->url.file);
          uri_free(uri, 1);
          return;
        } else {

        }
      } else {

      }
      uri->length = (int )uri->bdlen;
      goto done;
    } else {

    }
  }
  if (uri->length == -1) {
    tmp___1 = realloc((void *)uri->body, (uri->bdlen + (size_t )n) + 1U);
    p = (u_char *)tmp___1;
    if ((unsigned int )p == (unsigned int )((void *)0)) {
      warn("%s: realloc", "http_readbody");
      uri_free(uri, 1);
      return;
    } else {

    }
    uri->body = (char *)p;
    memcpy((void * __restrict  )(uri->body + uri->bdlen), (void const   * __restrict  )(body),
           (unsigned int )n);
    uri->bdlen = uri->bdlen + (size_t )n;
    *(uri->body + uri->bdlen) = (char )'\000';
  } else {
    uri->bdlen = uri->bdlen + (size_t )n;
    uri->bdread = uri->bdread + (size_t )n;
  }
  if (uri->length == -1) {
    goto readmore;
  } else {
    if (uri->bdlen < (size_t )uri->length) {
      goto readmore;
    } else {

    }
  }
  done: 
  http_dispatch(uri, 1);
  return;
  readmore: 
  tv.tv_usec = 0L;
  tv.tv_sec = tv.tv_usec;
  tv.tv_sec = 180L;
  event_add(& uri->ev, & tv);
  if (uri->length != -1) {
    if (uri->bdmemlen == uri->bdread) {
      http_dispatch(uri, 0);
    } else {

    }
  } else {

  }
  return;
}
}
int http_isrobotstxt(struct uri *uri ) 
{ int tmp ;
  int tmp___0 ;

  {
  if ((unsigned int )uri->url.file != (unsigned int )((void *)0)) {
    tmp = strcmp((char const   *)uri->url.file, "/robots.txt");
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
int http_robotstxt(struct uri *uri ) 
{ int tmp ;

  {
  if ((unsigned int )uri->url.file == (unsigned int )((void *)0)) {
    return (0);
  } else {

  }
  tmp = strcmp((char const   *)uri->url.file, "/robots.txt");
  if (tmp == 0) {
    http_robots_response(uri);
    return (1);
  } else {

  }
  return (0);
}
}
void http_dispatch(struct uri *uri , int mustfree ) 
{ struct dispatch *dispatch ;
  char *format ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  format = uri->format;
  if ((unsigned int )format == (unsigned int )((void *)0)) {
    format = (char *)"text/html";
  } else {

  }
  if (uri->length < 131072) {
    http_stats.headerbytes = http_stats.headerbytes + uri->hdlen;
    http_stats.bodybytes = http_stats.bodybytes + uri->bdlen;
  } else {
    if (uri->bdread == 0U) {
      http_stats.headerbytes = http_stats.headerbytes + uri->hdlen;
      http_stats.bodybytes = http_stats.bodybytes + uri->bdlen;
    } else {
      if (uri->bdlen == uri->bdmemlen) {
        http_stats.headerbytes = http_stats.headerbytes + uri->hdlen;
      } else {

      }
      http_stats.bodybytes = http_stats.bodybytes + uri->bdread;
    }
  }
  if ((int )uri->flags & 1) {
    http_stats.gets = http_stats.gets + 1U;
  } else {
    http_stats.heads = http_stats.heads + 1U;
  }
  if (use_robots) {
    tmp = http_robotstxt(uri);
    if (tmp) {
      uri_free(uri, 1);
      return;
    } else {

    }
  } else {

  }
  dispatch = dispatchqueue.tqh_first;
  while (1) {
    if ((unsigned int )dispatch != (unsigned int )((void *)0)) {

    } else {
      break;
    }
    tmp___1 = strlen((char const   *)dispatch->type);
    tmp___2 = strncasecmp((char const   *)format, (char const   *)dispatch->type,
                          tmp___1);
    if (tmp___2 == 0) {
      tmp___0 = (*(dispatch->cb))(uri);
      if (tmp___0 != -1) {
        break;
      } else {

      }
    } else {

    }
    dispatch = dispatch->next.tqe_next;
  }
  if (mustfree) {
    uri_free(uri, 1);
    return;
  } else {
    if ((unsigned int )dispatch == (unsigned int )((void *)0)) {
      uri_free(uri, 1);
      return;
    } else {

    }
  }
  return;
}
}
static char normal[1024]  ;
char *http_normalize_uri(char *uri ) 
{ char *host___0 ;
  char *file___0 ;
  char *p ;
  u_short port ;
  int tmp ;
  size_t tmp___0 ;
  char *p2 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *p2___0 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;

  {
  tmp = http_hostportfile(uri, & host___0, & port, & file___0);
  if (tmp == -1) {
    return ((char *)((void *)0));
  } else {

  }
  p = strchr((char const   *)file___0, '#');
  if ((unsigned int )p != (unsigned int )((void *)0)) {
    *p = (char )'\000';
  } else {

  }
  p = file___0;
  while (1) {
    p = strstr((char const   *)p, "/./");
    if ((unsigned int )p != (unsigned int )((void *)0)) {

    } else {
      break;
    }
    tmp___0 = strlen((char const   *)(p + 2));
    memmove((void *)p, (void const   *)(p + 2), tmp___0 + 1U);
  }
  p = file___0;
  while (1) {
    p = strstr((char const   *)p, "//");
    if ((unsigned int )p != (unsigned int )((void *)0)) {

    } else {
      break;
    }
    tmp___1 = strspn((char const   *)p, "/");
    p2 = p + tmp___1;
    tmp___2 = strlen((char const   *)p2);
    memmove((void *)(p + 1), (void const   *)p2, tmp___2 + 1U);
  }
  while (1) {
    p = strstr((char const   *)file___0, "/..");
    if ((unsigned int )p != (unsigned int )((void *)0)) {

    } else {
      break;
    }
    p2___0 = p - 1;
    while (1) {
      if ((unsigned int )p2___0 > (unsigned int )file___0) {

      } else {
        break;
      }
      if ((int )*p2___0 == 47) {
        break;
      } else {

      }
      p2___0 = p2___0 - 1;
    }
    if ((unsigned int )p2___0 <= (unsigned int )file___0) {
      tmp___3 = strlen((char const   *)(p + 3));
      memmove((void *)file___0, (void const   *)(p + 3), tmp___3 + 1U);
    } else {
      tmp___4 = strlen((char const   *)(p + 3));
      memmove((void *)p2___0, (void const   *)(p + 3), tmp___4 + 1U);
    }
  }
  if ((int )port != 80) {
    snprintf((char * __restrict  )(normal), sizeof(normal), (char const   * __restrict  )"http://%s:%d",
             host___0, port);
  } else {
    snprintf((char * __restrict  )(normal), sizeof(normal), (char const   * __restrict  )"http://%s",
             host___0);
  }
  p = normal;
  while (1) {
    if (*p) {

    } else {
      break;
    }
    tmp___5 = tolower((int )*p);
    *p = (char )tmp___5;
    p = p + 1;
  }
  tmp___6 = strlcat(normal, (char const   *)file___0, sizeof(normal));
  if (tmp___6 >= sizeof(normal)) {
    return ((char *)((void *)0));
  } else {

  }
  return (normal);
}
}
char *http_basename(struct uri *uri ) 
{ char *p ;
  char *url ;
  char *normal___1 ;

  {
  url = http_make_url(& uri->url);
  normal___1 = http_normalize_uri(url);
  if ((unsigned int )normal___1 == (unsigned int )((void *)0)) {
    return ((char *)((void *)0));
  } else {

  }
  p = strrchr((char const   *)normal___1, '/');
  if ((unsigned int )p == (unsigned int )((void *)0)) {
    return ((char *)((void *)0));
  } else {

  }
  if ((int )*(p + 1) != 0) {
    *(p + 1) = (char )'\000';
  } else {

  }
  return (normal___1);
}
}
static char normal___0[1024]  ;
char *http_make_uri(char *base , char *rel ) 
{ size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *host___0 ;
  char *file___0 ;
  u_short port ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  tmp = strlen("http://");
  tmp___0 = strncasecmp((char const   *)rel, "http://", tmp);
  if (tmp___0) {
    tmp___1 = strchr((char const   *)rel, ':');
    if ((unsigned int )tmp___1 != (unsigned int )((void *)0)) {
      return (rel);
    } else {

    }
  } else {
    return (rel);
  }
  if ((int )*(rel + 0) == 47) {
    tmp___2 = http_hostportfile(base, & host___0, & port, & file___0);
    if (tmp___2 == -1) {
      return ((char *)((void *)0));
    } else {

    }
    if ((int )port != 80) {
      snprintf((char * __restrict  )(normal___0), sizeof(normal___0), (char const   * __restrict  )"http://%s:%d%s",
               host___0, port, rel);
    } else {
      snprintf((char * __restrict  )(normal___0), sizeof(normal___0), (char const   * __restrict  )"http://%s%s",
               host___0, rel);
    }
  } else {
    if ((int )*(rel + 0) == 35) {
      return ((char *)((void *)0));
    } else {
      snprintf((char * __restrict  )(normal___0), sizeof(normal___0), (char const   * __restrict  )"%s%s",
               base, rel);
    }
  }
  tmp___3 = http_normalize_uri(normal___0);
  return (tmp___3);
}
}
int http_mark_seen(char *line ) 
{ char *normal___1 ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = http_normalize_uri(line);
  normal___1 = tmp;
  if ((unsigned int )normal___1 != (unsigned int )((void *)0)) {
    tmp___0 = db_seen(normal___1);
    tmp___1 = tmp___0;
  } else {
    tmp___1 = 1;
  }
  return (tmp___1);
}
}
static char output[1024]  ;
char *http_make_url(struct url *url ) 
{ 

  {
  if ((int )url->port != 80) {
    snprintf((char * __restrict  )(output), sizeof(output), (char const   * __restrict  )"http://%s:%d%s",
             url->host, url->port, url->file);
  } else {
    snprintf((char * __restrict  )(output), sizeof(output), (char const   * __restrict  )"http://%s%s",
             url->host, url->file);
  }
  return (output);
}
}
#pragma merger(0,"/tmp/cil-LPodRAcG.i","-Wall")
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
extern int fcntl(int __fd , int __cmd  , ...) ;
int connection_new(struct addrinfo *ai , u_short port ) 
{ int res ;
  int sock ;
  int tmp ;
  int *tmp___0 ;

  {
  ((struct sockaddr_in *)((void *)ai->ai_addr))->sin_port = htons(port);
  sock = socket(ai->ai_family, 1, 0);
  if (sock == -1) {
    warn("%s: socket", "connection_new");
    return (-1);
  } else {

  }
  tmp = fcntl(sock, 4, 2048);
  if (tmp == -1) {
    warn("%s: fcntl", "connection_new");
    close(sock);
    return (-1);
  } else {

  }
  res = connect(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
  if (res == -1) {
    tmp___0 = __errno_location();
    if (*tmp___0 != 115) {
      warn("%s: connect", "connection_new");
      close(sock);
      return (-1);
    } else {

    }
  } else {

  }
  return (sock);
}
}
#pragma merger(0,"/tmp/cil-bPVqUrG2.i","-Wall")
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n ) 
{ char *s ;
  ssize_t res ;
  ssize_t pos ;
  int *tmp ;
  int *tmp___0 ;

  {
  s = (char *)_s;
  pos = 0;
  while (1) {
    if (n > (size_t )pos) {

    } else {
      break;
    }
    res = (*f)(fd, s + pos, n - (size_t )pos);
    switch (res) {
    case -1: 
    tmp = __errno_location();
    if (*tmp == 4) {
      continue;
    } else {
      tmp___0 = __errno_location();
      if (*tmp___0 == 11) {
        continue;
      } else {

      }
    }
    case 0: 
    return (res);
    default: 
    pos = pos + res;
    }
  }
  return (pos);
}
}
#pragma merger(0,"/tmp/cil-0CYRMAny.i","-Wall")
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept )  __attribute__((__pure__,
__nonnull__(1,2))) ;
int html_parse_setbase(struct html_parse *p , char *base ) ;
char *strdupend(char *s , char *end ) ;
char **html_attr_find(char **attr , char *name ) 
{ int tmp ;

  {
  while (1) {
    if ((unsigned int )*attr != (unsigned int )((void *)0)) {

    } else {
      break;
    }
    tmp = strcasecmp((char const   *)*attr, (char const   *)name);
    if (tmp) {

    } else {
      break;
    }
    attr = attr + 2;
  }
  return (attr);
}
}
void html_free_cb(struct html_cb *cb ) 
{ 

  {
  if ((unsigned int )cb->name != (unsigned int )((void *)0)) {
    free((void *)cb->name);
  } else {

  }
  free((void *)cb);
  return;
}
}
int html_register_cb(struct html_parse *p , char *name , void (*callback)(void * ,
                                                                          char * ,
                                                                          char ** ) ) 
{ struct html_cb *cb ;
  void *tmp ;
  char *tmp___0 ;

  {
  tmp = malloc(sizeof(struct html_cb ));
  cb = (struct html_cb *)tmp;
  if ((unsigned int )cb == (unsigned int )((void *)0)) {
    return (-1);
  } else {

  }
  cb->cb = callback;
  tmp___0 = strdup((char const   *)name);
  cb->name = tmp___0;
  if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
    goto out;
  } else {

  }
  while (1) {
    cb->next.tqe_next = (struct html_cb *)((void *)0);
    cb->next.tqe_prev = p->cbqueue.tqh_last;
    *(p->cbqueue.tqh_last) = cb;
    p->cbqueue.tqh_last = & cb->next.tqe_next;
    break;
  }
  return (0);
  out: 
  html_free_cb(cb);
  return (-1);
}
}
struct html_parse *html_newparser(void) 
{ struct html_parse *p ;
  void *tmp ;

  {
  tmp = calloc(1U, sizeof(struct html_parse ));
  p = (struct html_parse *)tmp;
  if ((unsigned int )p == (unsigned int )((void *)0)) {
    return ((struct html_parse *)((void *)0));
  } else {

  }
  while (1) {
    p->cbqueue.tqh_first = (struct html_cb *)((void *)0);
    p->cbqueue.tqh_last = & p->cbqueue.tqh_first;
    break;
  }
  return (p);
}
}
void html_freeparser(struct html_parse *p ) 
{ struct html_cb *cb ;

  {
  if ((unsigned int )p->base != (unsigned int )((void *)0)) {
    free((void *)p->base);
  } else {

  }
  cb = p->cbqueue.tqh_first;
  while (1) {
    if (cb) {

    } else {
      break;
    }
    while (1) {
      if ((unsigned int )cb->next.tqe_next != (unsigned int )((void *)0)) {
        (cb->next.tqe_next)->next.tqe_prev = cb->next.tqe_prev;
      } else {
        p->cbqueue.tqh_last = cb->next.tqe_prev;
      }
      *(cb->next.tqe_prev) = cb->next.tqe_next;
      break;
    }
    html_free_cb(cb);
    cb = p->cbqueue.tqh_first;
  }
  free((void *)p);
  return;
}
}
int html_parse_setbase(struct html_parse *p , char *base ) 
{ int tmp ;

  {
  if ((unsigned int )p->base != (unsigned int )((void *)0)) {
    free((void *)p->base);
  } else {

  }
  p->base = strdup((char const   *)base);
  if ((unsigned int )p->base == (unsigned int )((void *)0)) {
    tmp = -1;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
void tag_start(struct html_parse *p , char *el , char **attr ) 
{ struct html_cb *cb ;
  void *arg ;
  int tmp ;

  {
  if ((unsigned int )p->data != (unsigned int )((void *)0)) {
    arg = p->data;
  } else {
    arg = (void *)p;
  }
  cb = p->cbqueue.tqh_first;
  while (1) {
    if ((unsigned int )cb != (unsigned int )((void *)0)) {

    } else {
      break;
    }
    tmp = strcasecmp((char const   *)cb->name, (char const   *)el);
    if (tmp) {

    } else {
      (*(cb->cb))(arg, el, attr);
      break;
    }
    cb = cb->next.tqe_next;
  }
  return;
}
}
void tag_end(struct html_parse *parser___0 , char *el ) 
{ 

  {
  return;
}
}
void html_parsetag(struct html_parse *parser___0 , char *start , char *end ) 
{ char *element ;
  char *elend ;
  char *attr ;
  char *attrend ;
  char **pattr ;
  char **pattrend ;
  char *attrlist[22] ;
  int endtag ;
  int i ;
  char quoted ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char delim[5] ;

  {
  endtag = 0;
  tmp = strspn((char const   *)(start + 1), " \r\n\t");
  start = (start + 1) + tmp;
  elend = strpbrk((char const   *)start, " \r\n\t>");
  if ((unsigned int )start >= (unsigned int )end) {
    return;
  } else {

  }
  if ((int )*start == 47) {
    endtag = 1;
    start = start + 1;
    if ((unsigned int )start >= (unsigned int )end) {
      return;
    } else {

    }
  } else {

  }
  element = strdupend(start, elend);
  if ((unsigned int )element == (unsigned int )((void *)0)) {
    return;
  } else {

  }
  memset((void *)(attrlist), 0, sizeof(attrlist));
  if (endtag) {
    tag_end(parser___0, element);
    goto out;
  } else {

  }
  attr = elend;
  pattr = attrlist;
  pattrend = pattr + 20;
  while (1) {
    if ((unsigned int )attr < (unsigned int )end) {
      if ((unsigned int )pattr < (unsigned int )pattrend) {

      } else {
        break;
      }
    } else {
      break;
    }
    tmp___0 = strspn((char const   *)attr, " \r\n\t");
    attr = attr + tmp___0;
    attrend = strpbrk((char const   *)attr, " \r\n\t=>");
    if ((unsigned int )attrend >= (unsigned int )end) {
      break;
    } else {

    }
    *pattr = strdupend(attr, attrend);
    if ((unsigned int )*pattr == (unsigned int )((void *)0)) {
      goto out;
    } else {

    }
    pattr = pattr + 1;
    tmp___1 = strspn((char const   *)attrend, " \r\n\t=>");
    attr = attrend + tmp___1;
    if ((int )*attr == 34) {
      quoted = *attr;
      attr = attr + 1;
      sprintf((char * __restrict  )(delim), (char const   * __restrict  )"%c>\r\n",
              quoted);
      attrend = strpbrk((char const   *)attr, (char const   *)(delim));
    } else {
      if ((int )*attr == 39) {
        quoted = *attr;
        attr = attr + 1;
        sprintf((char * __restrict  )(delim), (char const   * __restrict  )"%c>\r\n",
                quoted);
        attrend = strpbrk((char const   *)attr, (char const   *)(delim));
      } else {
        quoted = (char )'\000';
        attrend = strpbrk((char const   *)attr, " \r\n\t>");
      }
    }
    if ((unsigned int )attrend == (unsigned int )((void *)0)) {
      goto out;
    } else {

    }
    *pattr = strdupend(attr, attrend);
    if ((unsigned int )*pattr == (unsigned int )((void *)0)) {
      goto out;
    } else {

    }
    pattr = pattr + 1;
    if ((int )*attrend == (int )quoted) {
      attrend = attrend + 1;
    } else {

    }
    attr = attrend;
  }
  tag_start(parser___0, element, attrlist);
  out: 
  i = 0;
  while (1) {
    if (i < 20) {

    } else {
      break;
    }
    if ((unsigned int )attrlist[i] != (unsigned int )((void *)0)) {
      free((void *)attrlist[i]);
    } else {

    }
    i = i + 1;
  }
  free((void *)element);
  return;
}
}
int html_parser(struct html_parse *parser___0 , char *body___0 , size_t len ) 
{ int res ;
  char *p ;
  char *end ;
  char *tagend ;
  int tmp ;

  {
  res = 0;
  p = body___0;
  end = p + len;
  while (1) {
    if ((unsigned int )p < (unsigned int )end) {

    } else {
      break;
    }
    p = strchr((char const   *)p, '<');
    if ((unsigned int )p == (unsigned int )((void *)0)) {
      break;
    } else {

    }
    tmp = strncmp((char const   *)p, "<!--", 4U);
    if (tmp) {
      tagend = strchr((char const   *)p, '>');
    } else {
      tagend = strstr((char const   *)p, "-->");
      if ((unsigned int )tagend == (unsigned int )((void *)0)) {
        break;
      } else {

      }
      p = tagend + 3;
      continue;
    }
    if ((unsigned int )tagend == (unsigned int )((void *)0)) {
      break;
    } else {

    }
    html_parsetag(parser___0, p, tagend);
    p = tagend + 1;
  }
  return (res);
}
}
#pragma merger(0,"/tmp/cil-ZkLfO0TH.i","-Wall")
extern DB *__db185_open(char const   * , int  , int  , DBTYPE  , void const   * ) ;
void MD5Init(struct MD5Context *ctx ) ;
void MD5Update(struct MD5Context *ctx , unsigned char const   *buf , unsigned int len ) ;
void MD5Final(unsigned char *digest___0 , struct MD5Context *ctx ) ;
DB *db  ;
static DBT key  ;
static u_char digest[16]  ;
DBT *db_key(char *line ) 
{ MD5_CTX ctx ;
  int i ;
  size_t tmp ;

  {
  MD5Init(& ctx);
  tmp = strlen((char const   *)line);
  MD5Update(& ctx, (unsigned char const   *)line, tmp + 1U);
  MD5Final((unsigned char *)(digest), & ctx);
  i = 0;
  while (1) {
    if (i < 8) {

    } else {
      break;
    }
    digest[i] = (unsigned char )((int )digest[i] ^ (int )digest[i + 8]);
    i = i + 1;
  }
  key.data = (void *)(digest);
  key.size = 8U;
  return (& key);
}
}
int db_seen(char *line ) 
{ DBT *key___0 ;
  DBT data ;
  time_t now ;
  int res ;

  {
  key___0 = db_key(line);
  res = (*(db->get))((struct __db  const  *)db, (DBT const   *)key___0, & data, 0U);
  if (res != 1) {
    return (1);
  } else {

  }
  now = time((time_t *)((void *)0));
  data.data = (void *)(& now);
  data.size = sizeof(now);
  res = (*(db->put))((struct __db  const  *)db, key___0, (DBT const   *)(& data),
                     0U);
  return (0);
}
}
void db_setup(char *file___0 ) 
{ int flags ;
  int mode ;
  BTREEINFO binfo ;

  {
  flags = 66;
  mode = 384;
  memset((void *)(& binfo), 0, sizeof(binfo));
  binfo.cachesize = 10000000U;
  db = __db185_open((char const   *)file___0, flags, mode, 0, (void const   *)(& binfo));
  if ((unsigned int )db == (unsigned int )((void *)0)) {
    errx(1, "dbopen");
  } else {

  }
  return;
}
}
void db_close(void) 
{ 

  {
  (*(db->close))(db);
  return;
}
}
#pragma merger(0,"/tmp/cil-uFoeMZPA.i","-Wall")
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) size_t strcspn(char const   *__s , char const   *__reject )  __attribute__((__pure__,
__nonnull__(1,2))) ;
 __attribute__((__nothrow__)) char *dirname(char const   *path___0 ) ;
extern  __attribute__((__nothrow__)) char *__xpg_basename(char *__path ) ;
char *Media_list[43]  = 
  {      (char *)".aiff",      (char *)".aif",      (char *)".asf",      (char *)".asx", 
        (char *)".avi",      (char *)".au",      (char *)".bmp",      (char *)".dl", 
        (char *)".fli",      (char *)".gif",      (char *)".gl",      (char *)".jpg", 
        (char *)".jpeg",      (char *)".jpe",      (char *)".mid",      (char *)".midi", 
        (char *)".mp3",      (char *)"m3a",      (char *)".mpg",      (char *)".mpa", 
        (char *)".mp2",      (char *)".m2a",      (char *)".mpeg",      (char *)".mpe", 
        (char *)".pcx",      (char *)".pct",      (char *)".pict",      (char *)".png", 
        (char *)".qt",      (char *)".mov",      (char *)".moov",      (char *)".ra", 
        (char *)".ram",      (char *)".rm",      (char *)".rmp",      (char *)".tiff", 
        (char *)".tif",      (char *)".voc",      (char *)".viv",      (char *)".wav", 
        (char *)".wmv",      (char *)".xbm",      (char *)((void *)0)};
int isMedia(char *name ) 
{ char **listwalk ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  listwalk = Media_list;
  while (1) {
    if (*listwalk) {

    } else {
      break;
    }
    tmp = strlen((char const   *)*listwalk);
    len = (int )tmp;
    tmp___0 = strlen((char const   *)name);
    if (tmp___0 > (size_t )len) {
      tmp___1 = strlen((char const   *)name);
      tmp___2 = strcasecmp((char const   *)((name + tmp___1) - len), (char const   *)*listwalk);
      if (tmp___2) {

      } else {
        break;
      }
    } else {

    }
    listwalk = listwalk + 1;
  }
  return ((unsigned int )*listwalk != (unsigned int )((void *)0));
}
}
int mkpath(char *path___0 , mode_t mode , mode_t dir_mode ) 
{ struct stat sb ;
  register char *slash ;
  int done ;
  size_t tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  mode_t tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  done = 0;
  slash = strdup((char const   *)path___0);
  path___0 = slash;
  if ((unsigned int )path___0 == (unsigned int )((void *)0)) {
    warn("strdup");
    return (-1);
  } else {

  }
  while (1) {
    if (! done) {

    } else {
      break;
    }
    tmp = strspn((char const   *)slash, "/");
    slash = slash + tmp;
    tmp___0 = strcspn((char const   *)slash, "/");
    slash = slash + tmp___0;
    done = (int )*slash == 0;
    *slash = (char )'\000';
    tmp___6 = stat((char const   * __restrict  )path___0, (struct stat * __restrict  )(& sb));
    if (tmp___6) {
      tmp___1 = __errno_location();
      if (*tmp___1 != 2) {
        warn("%s", path___0);
        goto err;
      } else {
        if (done) {
          tmp___2 = mode;
        } else {
          tmp___2 = dir_mode;
        }
        tmp___3 = mkdir((char const   *)path___0, tmp___2);
        if (tmp___3) {
          tmp___4 = __errno_location();
          if (*tmp___4 != 17) {
            warn("%s", path___0);
            goto err;
          } else {

          }
        } else {

        }
      }
    } else {
      if (! ((sb.st_mode & 61440U) == 16384U)) {
        tmp___5 = strerror(20);
        warnx("%s: %s", path___0, tmp___5);
        goto err;
      } else {

      }
    }
    *slash = (char )'/';
  }
  free((void *)path___0);
  return (0);
  err: 
  free((void *)path___0);
  return (-1);
}
}
char *strdupend(char *s , char *end ) 
{ char *p ;
  char *str ;
  int len ;
  void *tmp ;

  {
  p = s;
  while (1) {
    if (*p) {
      if ((unsigned int )p < (unsigned int )end) {

      } else {
        break;
      }
    } else {
      break;
    }
    p = p + 1;
  }
  len = p - s;
  tmp = malloc((unsigned int )(len + 1));
  str = (char *)tmp;
  if ((unsigned int )str == (unsigned int )((void *)0)) {
    return ((char *)((void *)0));
  } else {

  }
  memcpy((void * __restrict  )str, (void const   * __restrict  )s, (unsigned int )len);
  *(str + len) = (char )'\000';
  return (str);
}
}
static char path[1024]  ;
char *construct_path(char *uri , int mkdir___0 ) 
{ char *dir ;
  mode_t mode ;
  mode_t dir_mode ;
  __mode_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
  tmp = umask(0U);
  mode = 511U & ~ tmp;
  dir_mode = (mode | 128U) | 64U;
  dir = dirname(uri);
  strlcpy(path, (char const   *)saveimgdir, sizeof(path) - 1U);
  tmp___0 = strlen((char const   *)(path));
  if ((int )path[tmp___0 - 1U] != 47) {
    strlcat(path, "/", sizeof(path));
  } else {

  }
  tmp___1 = strlcat(path, (char const   *)((dir + sizeof("http://")) - 1), sizeof(path));
  if (tmp___1 > sizeof(path)) {
    return ((char *)((void *)0));
  } else {

  }
  if (mkdir___0) {
    tmp___2 = mkpath(path, mode, dir_mode);
    if (tmp___2 == -1) {
      return ((char *)((void *)0));
    } else {

    }
  } else {

  }
  tmp___3 = strlen((char const   *)(path));
  if ((int )path[tmp___3 - 1U] != 47) {
    strlcat(path, "/", sizeof(path));
  } else {

  }
  tmp___4 = __xpg_basename(uri);
  tmp___5 = strlcat(path, (char const   *)tmp___4, sizeof(path));
  if (tmp___5 > sizeof(path)) {
    return ((char *)((void *)0));
  } else {

  }
  return (path);
}
}
#pragma merger(0,"/tmp/cil-962vVnVi.i","-Wall")
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
struct dns_child children[3]  ;
int childnr  =    0;
struct stats___0 dns_stats  ;
struct tree root  ;
static int compare(struct dns_entry *a , struct dns_entry *b ) 
{ int tmp ;

  {
  dns_stats.iterations = dns_stats.iterations + 1;
  tmp = strcasecmp((char const   *)a->name, (char const   *)b->name);
  return (tmp);
}
}
void tree_SPLAY(struct tree *head , struct dns_entry *elm ) ;
void tree_SPLAY_MINMAX(struct tree *head , int __comp ) ;
__inline static void tree_SPLAY_INSERT(struct tree *head , struct dns_entry *elm ) 
{ struct dns_entry *tmp ;
  int __comp ;

  {
  if ((unsigned int )head->sph_root == (unsigned int )((void *)0)) {
    tmp = (struct dns_entry *)((void *)0);
    elm->splay_next.spe_right = tmp;
    elm->splay_next.spe_left = tmp;
  } else {
    tree_SPLAY(head, elm);
    __comp = compare(elm, head->sph_root);
    if (__comp < 0) {
      elm->splay_next.spe_left = (head->sph_root)->splay_next.spe_left;
      elm->splay_next.spe_right = head->sph_root;
      (head->sph_root)->splay_next.spe_left = (struct dns_entry *)((void *)0);
    } else {
      if (__comp > 0) {
        elm->splay_next.spe_right = (head->sph_root)->splay_next.spe_right;
        elm->splay_next.spe_left = head->sph_root;
        (head->sph_root)->splay_next.spe_right = (struct dns_entry *)((void *)0);
      } else {
        return;
      }
    }
  }
  head->sph_root = elm;
  return;
}
}
__inline static void tree_SPLAY_REMOVE(struct tree *head , struct dns_entry *elm ) 
{ struct dns_entry *__tmp ;
  int tmp ;

  {
  if ((unsigned int )head->sph_root == (unsigned int )((void *)0)) {
    return;
  } else {

  }
  tree_SPLAY(head, elm);
  tmp = compare(elm, head->sph_root);
  if (tmp == 0) {
    if ((unsigned int )(head->sph_root)->splay_next.spe_left == (unsigned int )((void *)0)) {
      head->sph_root = (head->sph_root)->splay_next.spe_right;
    } else {
      __tmp = (head->sph_root)->splay_next.spe_right;
      head->sph_root = (head->sph_root)->splay_next.spe_left;
      tree_SPLAY(head, elm);
      (head->sph_root)->splay_next.spe_right = __tmp;
    }
  } else {

  }
  return;
}
}
__inline static struct dns_entry *tree_SPLAY_FIND(struct tree *head , struct dns_entry *elm ) 
{ int tmp ;

  {
  if ((unsigned int )head->sph_root == (unsigned int )((void *)0)) {
    return ((struct dns_entry *)((void *)0));
  } else {

  }
  tree_SPLAY(head, elm);
  tmp = compare(elm, head->sph_root);
  if (tmp == 0) {
    return (head->sph_root);
  } else {

  }
  return ((struct dns_entry *)((void *)0));
}
}
void tree_SPLAY(struct tree *head , struct dns_entry *elm ) 
{ struct dns_entry __node ;
  struct dns_entry *__left ;
  struct dns_entry *__right ;
  struct dns_entry *__tmp ;
  int __comp ;
  int tmp ;
  int tmp___0 ;

  {
  __node.splay_next.spe_right = (struct dns_entry *)((void *)0);
  __node.splay_next.spe_left = __node.splay_next.spe_right;
  __right = & __node;
  __left = __right;
  while (1) {
    __comp = compare(elm, head->sph_root);
    if (__comp) {

    } else {
      break;
    }
    if (__comp < 0) {
      if ((unsigned int )(head->sph_root)->splay_next.spe_left == (unsigned int )((void *)0)) {
        break;
      } else {

      }
      tmp = compare(elm, (head->sph_root)->splay_next.spe_left);
      if (tmp < 0) {
        while (1) {
          __tmp = (head->sph_root)->splay_next.spe_left;
          (head->sph_root)->splay_next.spe_left = __tmp->splay_next.spe_right;
          __tmp->splay_next.spe_right = head->sph_root;
          head->sph_root = __tmp;
          break;
        }
        if ((unsigned int )(head->sph_root)->splay_next.spe_left == (unsigned int )((void *)0)) {
          break;
        } else {

        }
      } else {

      }
      while (1) {
        __right->splay_next.spe_left = head->sph_root;
        __right = head->sph_root;
        head->sph_root = (head->sph_root)->splay_next.spe_left;
        break;
      }
    } else {
      if (__comp > 0) {
        if ((unsigned int )(head->sph_root)->splay_next.spe_right == (unsigned int )((void *)0)) {
          break;
        } else {

        }
        tmp___0 = compare(elm, (head->sph_root)->splay_next.spe_right);
        if (tmp___0 > 0) {
          while (1) {
            __tmp = (head->sph_root)->splay_next.spe_right;
            (head->sph_root)->splay_next.spe_right = __tmp->splay_next.spe_left;
            __tmp->splay_next.spe_left = head->sph_root;
            head->sph_root = __tmp;
            break;
          }
          if ((unsigned int )(head->sph_root)->splay_next.spe_right == (unsigned int )((void *)0)) {
            break;
          } else {

          }
        } else {

        }
        while (1) {
          __left->splay_next.spe_right = head->sph_root;
          __left = head->sph_root;
          head->sph_root = (head->sph_root)->splay_next.spe_right;
          break;
        }
      } else {

      }
    }
  }
  while (1) {
    __left->splay_next.spe_right = (head->sph_root)->splay_next.spe_left;
    __right->splay_next.spe_left = (head->sph_root)->splay_next.spe_right;
    (head->sph_root)->splay_next.spe_left = __node.splay_next.spe_right;
    (head->sph_root)->splay_next.spe_right = __node.splay_next.spe_left;
    break;
  }
  return;
}
}
void tree_SPLAY_MINMAX(struct tree *head , int __comp ) 
{ struct dns_entry __node ;
  struct dns_entry *__left ;
  struct dns_entry *__right ;
  struct dns_entry *__tmp ;

  {
  __node.splay_next.spe_right = (struct dns_entry *)((void *)0);
  __node.splay_next.spe_left = __node.splay_next.spe_right;
  __right = & __node;
  __left = __right;
  while (1) {
    if (__comp < 0) {
      if ((unsigned int )(head->sph_root)->splay_next.spe_left == (unsigned int )((void *)0)) {
        break;
      } else {

      }
      if (__comp < 0) {
        while (1) {
          __tmp = (head->sph_root)->splay_next.spe_left;
          (head->sph_root)->splay_next.spe_left = __tmp->splay_next.spe_right;
          __tmp->splay_next.spe_right = head->sph_root;
          head->sph_root = __tmp;
          break;
        }
        if ((unsigned int )(head->sph_root)->splay_next.spe_left == (unsigned int )((void *)0)) {
          break;
        } else {

        }
      } else {

      }
      while (1) {
        __right->splay_next.spe_left = head->sph_root;
        __right = head->sph_root;
        head->sph_root = (head->sph_root)->splay_next.spe_left;
        break;
      }
    } else {
      if (__comp > 0) {
        if ((unsigned int )(head->sph_root)->splay_next.spe_right == (unsigned int )((void *)0)) {
          break;
        } else {

        }
        if (__comp > 0) {
          while (1) {
            __tmp = (head->sph_root)->splay_next.spe_right;
            (head->sph_root)->splay_next.spe_right = __tmp->splay_next.spe_left;
            __tmp->splay_next.spe_left = head->sph_root;
            head->sph_root = __tmp;
            break;
          }
          if ((unsigned int )(head->sph_root)->splay_next.spe_right == (unsigned int )((void *)0)) {
            break;
          } else {

          }
        } else {

        }
        while (1) {
          __left->splay_next.spe_right = head->sph_root;
          __left = head->sph_root;
          head->sph_root = (head->sph_root)->splay_next.spe_right;
          break;
        }
      } else {

      }
    }
  }
  while (1) {
    __left->splay_next.spe_right = (head->sph_root)->splay_next.spe_left;
    __right->splay_next.spe_left = (head->sph_root)->splay_next.spe_right;
    (head->sph_root)->splay_next.spe_left = __node.splay_next.spe_right;
    (head->sph_root)->splay_next.spe_right = __node.splay_next.spe_left;
    break;
  }
  return;
}
}
void dns_child(int rfd , int wfd ) ;
void dns_remove(struct dns_entry *dns ) ;
struct dns_list dnsqueue  ;
int entries  ;
void dns_makeaddrinfo(struct addrinfo **pai , struct dns_transport *dt ) 
{ struct addrinfo *ai ;
  void *tmp ;

  {
  tmp = calloc(1U, sizeof(struct addrinfo ) + dt->ai.ai_addrlen);
  ai = (struct addrinfo *)tmp;
  if ((unsigned int )ai == (unsigned int )((void *)0)) {
    err(1, "%s: malloc", "dns_makeaddrinfo");
  } else {

  }
  *ai = dt->ai;
  ai->ai_addr = (struct sockaddr *)(ai + 1);
  memcpy((void * __restrict  )ai->ai_addr, (void const   * __restrict  )(& dt->dns_addr),
         ai->ai_addrlen);
  ai->ai_next = *pai;
  *pai = ai;
  return;
}
}
void dns_read(int fd , short why , void *arg ) 
{ struct dns_child *child ;
  struct dns_entry *dns ;
  struct addrinfo *ai ;
  struct timeval tv ;
  u_char *buf ;
  int size ;
  ssize_t tmp ;
  char *p ;
  void *tmp___0 ;
  ssize_t tmp___1 ;

  {
  child = (struct dns_child *)arg;
  ai = (struct addrinfo *)((void *)0);
  dns = child->waitqueue.tqh_first;
  while (1) {
    if ((unsigned int )dns->wait_next.tqe_next != (unsigned int )((void *)0)) {
      (dns->wait_next.tqe_next)->wait_next.tqe_prev = dns->wait_next.tqe_prev;
    } else {
      child->waitqueue.tqh_last = dns->wait_next.tqe_prev;
    }
    *(dns->wait_next.tqe_prev) = dns->wait_next.tqe_next;
    break;
  }
  child->waits = child->waits - 1;
  if (child->waits) {
    event_add(& child->ev_write, (struct timeval *)((void *)0));
  } else {

  }
  tmp = atomicio((ssize_t (*)())(& read), fd, (void *)(& size), sizeof(size));
  if ((unsigned int )tmp != sizeof(size)) {
    err(1, "%s: read(%d)", "dns_read", sizeof(size));
  } else {

  }
  if (size == -1) {
    goto fail;
  } else {

  }
  if (size > 0) {
    tmp___0 = malloc((unsigned int )size);
    buf = (u_char *)tmp___0;
    if ((unsigned int )buf == (unsigned int )((void *)0)) {
      err(1, "%s: malloc", "dns_read");
    } else {

    }
    tmp___1 = atomicio((ssize_t (*)())(& read), fd, (void *)buf, (unsigned int )size);
    if (tmp___1 != size) {
      err(1, "%s: read(%d)", "dns_read", size);
    } else {

    }
    p = (char *)buf;
    while (1) {
      if (size) {

      } else {
        break;
      }
      dns_makeaddrinfo(& ai, (struct dns_transport *)p);
      p = p + sizeof(struct dns_transport );
      size = (int )((unsigned int )size - sizeof(struct dns_transport ));
    }
    free((void *)buf);
  } else {
    ai = (struct addrinfo *)((void *)0);
  }
  if (debug >= 2) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: return for %s: %p\n",
            "dns_read", dns->name, ai);
  } else {

  }
  dns->ai = ai;
  if ((unsigned int )ai != (unsigned int )((void *)0)) {
    dns->flags = (unsigned short)1;
  } else {
    dns->flags = (unsigned short)0;
  }
  (*(dns->cb))(ai, dns, dns->cbarg);
  return;
  fail: 
  if (debug >= 2) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: error for %s\n",
            "dns_read", dns->name);
  } else {

  }
  dns->ai = (struct addrinfo *)((void *)0);
  dns->retries = dns->retries + 1;
  if (dns->retries > 3) {
    dns->flags = (unsigned short)0;
  } else {
    dns->flags = (unsigned short)2;
    gettimeofday((struct timeval * __restrict  )(& dns->access), (struct timezone * __restrict  )((void *)0));
    tv.tv_usec = 0L;
    tv.tv_sec = tv.tv_usec;
    tv.tv_sec = 60L;
    while (1) {
      dns->access.tv_sec = tv.tv_sec + dns->access.tv_sec;
      dns->access.tv_usec = tv.tv_usec + dns->access.tv_usec;
      if (dns->access.tv_usec >= 1000000L) {
        dns->access.tv_sec = dns->access.tv_sec + 1L;
        dns->access.tv_usec = dns->access.tv_usec - 1000000L;
      } else {

      }
      break;
    }
  }
  (*(dns->cb))((struct addrinfo *)((void *)0), dns, dns->cbarg);
  return;
}
}
void dns_write(int fd , short why , void *arg ) 
{ struct dns_child *child ;
  struct dns_entry *dns ;
  int size ;
  size_t tmp ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;

  {
  child = (struct dns_child *)arg;
  dns = child->waitqueue.tqh_first;
  tmp = strlen((char const   *)dns->name);
  size = (int )(tmp + 1U);
  tmp___0 = atomicio((ssize_t (*)())(& write), fd, (void *)(& size), sizeof(size));
  if ((unsigned int )tmp___0 != sizeof(size)) {
    err(1, "write");
  } else {

  }
  tmp___1 = atomicio((ssize_t (*)())(& write), fd, (void *)dns->name, (unsigned int )size);
  if (tmp___1 != size) {
    err(1, "write");
  } else {

  }
  event_add(& child->ev_read, (struct timeval *)((void *)0));
  return;
}
}
int dns_set_child(struct dns_child *child ) 
{ int cmd[2] ;
  int res[2] ;
  int tmp ;
  int tmp___0 ;
  __sighandler_t tmp___1 ;

  {
  memset((void *)child, 0, sizeof(struct dns_child ));
  tmp = pipe((int *)(cmd));
  if (tmp == -1) {
    err(1, "pipe");
  } else {

  }
  tmp___0 = pipe((int *)(res));
  if (tmp___0 == -1) {
    err(1, "pipe");
  } else {

  }
  tmp___1 = signal(17, (void (*)(int  ))1);
  if ((unsigned int )tmp___1 == (unsigned int )((void (*)(int  ))-1)) {
    err(1, "signal");
  } else {

  }
  child->pid = fork();
  if (child->pid == 0) {
    close(cmd[1]);
    close(res[0]);
    dns_child(cmd[0], res[1]);
    exit(0);
  } else {
    if (child->pid == -1) {
      err(1, "fork");
    } else {

    }
  }
  close(cmd[0]);
  close(res[1]);
  child->cmd_write = cmd[1];
  child->res_read = res[0];
  child->waits = 0;
  while (1) {
    child->waitqueue.tqh_first = (struct dns_entry *)((void *)0);
    child->waitqueue.tqh_last = & child->waitqueue.tqh_first;
    break;
  }
  event_set(& child->ev_read, child->res_read, (short)2, & dns_read, (void *)child);
  event_set(& child->ev_write, child->cmd_write, (short)4, & dns_write, (void *)child);
  return (0);
}
}
void dns_init(void) 
{ int i ;

  {
  while (1) {
    dnsqueue.tqh_first = (struct dns_entry *)((void *)0);
    dnsqueue.tqh_last = & dnsqueue.tqh_first;
    break;
  }
  while (1) {
    root.sph_root = (struct dns_entry *)((void *)0);
    break;
  }
  memset((void *)(& dns_stats), 0, sizeof(dns_stats));
  i = 0;
  while (1) {
    if (i < 3) {

    } else {
      break;
    }
    dns_set_child(& children[i]);
    i = i + 1;
  }
  entries = 0;
  return;
}
}
void dns_end(void) 
{ int i ;

  {
  i = 0;
  while (1) {
    if (i < 3) {

    } else {
      break;
    }
    kill(children[i].pid, 15);
    i = i + 1;
  }
  return;
}
}
void dns_print_stats(void) 
{ 

  {
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"DNS queries: %d, entries: %d\n",
          dns_stats.calls, entries);
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"DNS cache hits: %d, replacements: %d\n",
          dns_stats.hits, dns_stats.replacements);
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"DNS average list search: %f\n",
          (float )dns_stats.iterations / (float )dns_stats.calls);
  return;
}
}
void dns_unref(struct dns_entry *dns ) 
{ 

  {
  if ((int )dns->ref == 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s(%p) already unref\n",
            "dns_unref", dns->name, dns);
    return;
  } else {

  }
  dns->ref = (short )((int )dns->ref - 1);
  return;
}
}
void dns_ref(struct dns_entry *dns ) 
{ 

  {
  dns->ref = (short )((int )dns->ref + 1);
  return;
}
}
void dns_remove(struct dns_entry *dns ) 
{ 

  {
  while (1) {
    if ((unsigned int )dns->next.tqe_next != (unsigned int )((void *)0)) {
      (dns->next.tqe_next)->next.tqe_prev = dns->next.tqe_prev;
    } else {
      dnsqueue.tqh_last = dns->next.tqe_prev;
    }
    *(dns->next.tqe_prev) = dns->next.tqe_next;
    break;
  }
  tree_SPLAY_REMOVE(& root, dns);
  if (dns->name) {
    free((void *)dns->name);
  } else {

  }
  if (dns->ai) {
    freeaddrinfo(dns->ai);
  } else {

  }
  memset((void *)dns, 0, sizeof(struct dns_entry ));
  return;
}
}
void dns_set(struct dns_entry *dns , char *name , void (*cb)(struct addrinfo * , struct dns_entry * ,
                                                             void * ) , void *arg ) 
{ 

  {
  gettimeofday((struct timeval * __restrict  )(& dns->creat), (struct timezone * __restrict  )((void *)0));
  dns->access = dns->creat;
  dns->name = name;
  dns->flags = (unsigned short)32768;
  dns->cb = cb;
  dns->cbarg = arg;
  return;
}
}
struct addrinfo *dns_roundrobin(struct dns_entry *dns ) 
{ struct addrinfo *first ;
  struct addrinfo *tmp ;

  {
  first = dns->ai;
  if ((unsigned int )first == (unsigned int )((void *)0)) {
    return (first);
  } else {
    if ((unsigned int )first->ai_next == (unsigned int )((void *)0)) {
      return (first);
    } else {

    }
  }
  tmp = first->ai_next;
  dns->ai = tmp;
  first->ai_next = (struct addrinfo *)((void *)0);
  while (1) {
    if ((unsigned int )tmp->ai_next != (unsigned int )((void *)0)) {

    } else {
      break;
    }
    tmp = tmp->ai_next;
  }
  tmp->ai_next = first;
  return (first);
}
}
void dns_setdepth(struct dns_entry *dns , int depth ) 
{ struct dns_entry *tmp ;
  struct dns_entry *tmp___0 ;

  {
  if (depth == 0) {
    while (1) {
      if ((unsigned int )dns->next.tqe_next != (unsigned int )((void *)0)) {
        (dns->next.tqe_next)->next.tqe_prev = dns->next.tqe_prev;
      } else {
        dnsqueue.tqh_last = dns->next.tqe_prev;
      }
      *(dns->next.tqe_prev) = dns->next.tqe_next;
      break;
    }
    while (1) {
      dns->next.tqe_next = (struct dns_entry *)((void *)0);
      dns->next.tqe_prev = dnsqueue.tqh_last;
      *(dnsqueue.tqh_last) = dns;
      dnsqueue.tqh_last = & dns->next.tqe_next;
      break;
    }
    return;
  } else {

  }
  while (1) {
    tmp = *(((struct dns_list *)dns->next.tqe_prev)->tqh_last);
    if (tmp) {

    } else {
      break;
    }
    if (tmp->depth >= dns->depth) {
      break;
    } else {

    }
  }
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
    return;
  } else {

  }
  if ((unsigned int )tmp == (unsigned int )*(((struct dns_list *)dns->next.tqe_prev)->tqh_last)) {
    while (1) {
      tmp = dns->next.tqe_next;
      if (tmp) {

      } else {
        break;
      }
      if (tmp->depth <= dns->depth) {
        break;
      } else {

      }
    }
    if ((unsigned int )tmp == (unsigned int )((void *)0)) {
      return;
    } else {
      if ((unsigned int )tmp == (unsigned int )dns->next.tqe_next) {
        return;
      } else {

      }
    }
  } else {

  }
  while (1) {
    if ((unsigned int )dns->next.tqe_next != (unsigned int )((void *)0)) {
      (dns->next.tqe_next)->next.tqe_prev = dns->next.tqe_prev;
    } else {
      dnsqueue.tqh_last = dns->next.tqe_prev;
    }
    *(dns->next.tqe_prev) = dns->next.tqe_next;
    break;
  }
  while (1) {
    tmp___0 = tmp->next.tqe_next;
    dns->next.tqe_next = tmp___0;
    if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
      (dns->next.tqe_next)->next.tqe_prev = & dns->next.tqe_next;
    } else {
      dnsqueue.tqh_last = & dns->next.tqe_next;
    }
    tmp->next.tqe_next = dns;
    dns->next.tqe_prev = & tmp->next.tqe_next;
    break;
  }
  return;
}
}
struct dns_entry *dns_find(char *host___0 ) 
{ struct dns_entry *dns ;
  struct dns_entry tmp ;

  {
  tmp.name = host___0;
  dns_stats.calls = dns_stats.calls + 1;
  dns = tree_SPLAY_FIND(& root, & tmp);
  if ((unsigned int )dns != (unsigned int )((void *)0)) {
    dns_stats.hits = dns_stats.hits + 1;
  } else {

  }
  return (dns);
}
}
struct dns_entry *dns_get(void) 
{ struct dns_entry *dns ;
  void *tmp ;

  {
  dns = (struct dns_entry *)((void *)0);
  if (entries >= 65536) {
    dns_stats.replacements = dns_stats.replacements + 1;
    dns = *(((struct dns_list *)dnsqueue.tqh_last)->tqh_last);
    while (1) {
      if ((unsigned int )dns != (unsigned int )((void *)0)) {
        if (dns->ref) {

        } else {
          if ((unsigned int )dns->mediaqueue.tqh_first != (unsigned int )((void *)0)) {

          } else {
            if ((unsigned int )dns->uriqueue.tqh_first != (unsigned int )((void *)0)) {

            } else {
              break;
            }
          }
        }
      } else {
        break;
      }
      dns = *(((struct dns_list *)dns->next.tqe_prev)->tqh_last);
    }
    if ((unsigned int )dns != (unsigned int )((void *)0)) {
      dns_remove(dns);
    } else {

    }
  } else {

  }
  if ((unsigned int )dns == (unsigned int )((void *)0)) {
    tmp = calloc(1U, sizeof(struct dns_entry ));
    dns = (struct dns_entry *)tmp;
    entries = entries + 1;
  } else {

  }
  while (1) {
    dns->uriqueue.tqh_first = (struct uri_small *)((void *)0);
    dns->uriqueue.tqh_last = & dns->uriqueue.tqh_first;
    break;
  }
  while (1) {
    dns->mediaqueue.tqh_first = (struct uri_small *)((void *)0);
    dns->mediaqueue.tqh_last = & dns->mediaqueue.tqh_first;
    break;
  }
  return (dns);
}
}
int dns_ready(struct dns_entry *dns , struct timeval *tv , struct timeval *ready ,
              int max ) 
{ int res ;
  __suseconds_t tmp ;

  {
  tmp = 0L;
  ready->tv_usec = tmp;
  ready->tv_sec = tmp;
  if ((int )dns->flags & 32768) {
    return (0);
  } else {

  }
  if (max) {
    if ((int )dns->ref >= max) {
      return (0);
    } else {

    }
  } else {

  }
  if (dns->access.tv_sec == tv->tv_sec) {
    res = dns->access.tv_usec <= tv->tv_usec;
  } else {
    res = dns->access.tv_sec <= tv->tv_sec;
  }
  if (! res) {
    *ready = dns->access;
  } else {

  }
  return (res);
}
}
void dns_send(struct dns_entry *dns ) 
{ struct dns_child *child ;

  {
  childnr = childnr + 1;
  child = & children[childnr % 3];
  while (1) {
    dns->wait_next.tqe_next = (struct dns_entry *)((void *)0);
    dns->wait_next.tqe_prev = child->waitqueue.tqh_last;
    *(child->waitqueue.tqh_last) = dns;
    child->waitqueue.tqh_last = & dns->wait_next.tqe_next;
    break;
  }
  if (child->waits == 0) {
    event_add(& child->ev_write, (struct timeval *)((void *)0));
  } else {

  }
  child->waits = child->waits + 1;
  return;
}
}
int dns_resolve_cb(char *ip , u_short port , void (*cb)(struct addrinfo * , struct dns_entry * ,
                                                        void * ) , void *arg ) 
{ char *name ;
  struct dns_entry *dns ;
  struct addrinfo *ai ;
  int positive ;

  {
  ai = (struct addrinfo *)((void *)0);
  dns = dns_find(ip);
  if ((unsigned int )dns != (unsigned int )((void *)0)) {
    if ((int )dns->flags & 32768) {
      return (-1);
    } else {

    }
    if ((int )dns->flags & 2) {
      dns->cb = cb;
      dns->cbarg = arg;
      dns->flags = (unsigned short )((int )dns->flags | 32768);
      dns_send(dns);
      return (0);
    } else {

    }
    if ((int )dns->flags & 1) {
      ai = dns_roundrobin(dns);
    } else {
      ai = (struct addrinfo *)((void *)0);
    }
    (*cb)(ai, dns, arg);
    return (0);
  } else {

  }
  name = strdup((char const   *)ip);
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    warn("%s: strdup", "dns_resolve_cb");
    return (-1);
  } else {

  }
  positive = 0;
  dns = dns_get();
  if ((unsigned int )dns == (unsigned int )((void *)0)) {
    free((void *)name);
    return (-1);
  } else {

  }
  dns_set(dns, name, cb, arg);
  while (1) {
    dns->next.tqe_next = (struct dns_entry *)((void *)0);
    dns->next.tqe_prev = dnsqueue.tqh_last;
    *(dnsqueue.tqh_last) = dns;
    dnsqueue.tqh_last = & dns->next.tqe_next;
    break;
  }
  tree_SPLAY_INSERT(& root, dns);
  dns_send(dns);
  return (0);
}
}
int dns_resolve(char *ip , struct addrinfo **pai ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  int res ;
  char const   *tmp ;

  {
  memset((void *)(& hints), 0, sizeof(hints));
  hints.ai_family = 2;
  hints.ai_socktype = 1;
  res = getaddrinfo((char const   * __restrict  )ip, (char const   * __restrict  )((void *)0),
                    (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& ai));
  if (res != 0) {
    tmp = gai_strerror(res);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: getaddrinfo(%s): %s\n",
            "dns_resolve", ip, tmp);
    if (res != -5) {
      return (-1);
    } else {

    }
    ai = (struct addrinfo *)((void *)0);
  } else {

  }
  *pai = ai;
  return (0);
}
}
void dns_child_error(int fd ) 
{ int size ;
  ssize_t tmp ;

  {
  size = -1;
  tmp = atomicio((ssize_t (*)())(& write), fd, (void *)(& size), sizeof(size));
  if ((unsigned int )tmp != sizeof(size)) {
    exit(1);
  } else {

  }
  return;
}
}
void dns_child_success(int fd , struct addrinfo *ai ) 
{ int size ;
  char *buf ;
  char *p ;
  struct dns_transport *dt ;
  void *tmp ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;

  {
  size = 0;
  buf = (char *)((void *)0);
  while (1) {
    if ((unsigned int )ai != (unsigned int )((void *)0)) {

    } else {
      break;
    }
    size = (int )((unsigned int )size + sizeof(struct dns_transport ));
    tmp = realloc((void *)buf, (unsigned int )size);
    p = (char *)tmp;
    if ((unsigned int )p == (unsigned int )((void *)0)) {
      break;
    } else {

    }
    buf = p;
    dt = (struct dns_transport *)((buf + size) - sizeof(struct dns_transport ));
    dt->ai = *ai;
    dt->ai.ai_canonname = (char *)((void *)0);
    dt->ai.ai_next = (struct addrinfo *)((void *)0);
    dt->ai.ai_addr = (struct sockaddr *)((void *)0);
    memcpy((void * __restrict  )(& dt->dns_addr), (void const   * __restrict  )ai->ai_addr,
           ai->ai_addrlen);
    ai = ai->ai_next;
  }
  tmp___0 = atomicio((ssize_t (*)())(& write), fd, (void *)(& size), sizeof(size));
  if ((unsigned int )tmp___0 != sizeof(size)) {
    exit(1);
  } else {

  }
  if (size > 0) {
    tmp___1 = atomicio((ssize_t (*)())(& write), fd, (void *)buf, (unsigned int )size);
    if (tmp___1 != size) {
      exit(1);
    } else {

    }
  } else {

  }
  free((void *)buf);
  return;
}
}
void dns_child(int rfd , int wfd ) 
{ struct addrinfo *ai ;
  char line[1024] ;
  int i ;
  int size ;
  __sighandler_t tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;

  {
  i = 0;
  while (1) {
    if (i < 3) {
      if (children[i].pid) {

      } else {
        break;
      }
    } else {
      break;
    }
    close(children[i].cmd_write);
    close(children[i].res_read);
    i = i + 1;
  }
  tmp = signal(2, (void (*)(int  ))1);
  if ((unsigned int )tmp == (unsigned int )((void (*)(int  ))-1)) {
    err(1, "signal");
  } else {

  }
  while (1) {
    tmp___2 = atomicio((ssize_t (*)())(& read), rfd, (void *)(& size), sizeof(size));
    if ((unsigned int )tmp___2 == sizeof(size)) {

    } else {
      break;
    }
    if ((unsigned int )size > sizeof(line)) {
      break;
    } else {
      if (size < 0) {
        break;
      } else {

      }
    }
    tmp___0 = atomicio((ssize_t (*)())(& read), rfd, (void *)(line), (unsigned int )size);
    if (tmp___0 != size) {
      exit(1);
    } else {

    }
    tmp___1 = dns_resolve(line, & ai);
    if (tmp___1 == -1) {
      dns_child_error(wfd);
    } else {
      dns_child_success(wfd, ai);
      if ((unsigned int )ai != (unsigned int )((void *)0)) {
        freeaddrinfo(ai);
      } else {

      }
    }
  }
  exit(1);
}
}
#pragma merger(0,"/tmp/cil-oQkBxayJ.i","-Wall")
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
extern int fgetc(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) char *strncpy(char * __restrict  __dest , char const   * __restrict  __src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
char *conf_path ;
int conf_begin(void) ;
int conf_decode_base64(u_int8_t *out , u_int32_t *len , u_char *buf ) ;
int conf_end(int transaction , int commit ) ;
void conf_free_list(struct conf_list *list ) ;
int conf_get_line(FILE *stream , char *buf , u_int32_t len ) ;
struct conf_list *conf_get_list(char *section___0 , char *tag ) ;
struct conf_list *conf_get_tag_list(char *section___0 ) ;
int conf_match_num(char *section___0 , char *tag , int x ) ;
void conf_reinit(void) ;
int conf_remove(int transaction , char *section___0 , char *tag ) ;
int conf_remove_section(int transaction , char *section___0 ) ;
int conf_set(int transaction , char *section___0 , char *tag , char *value , int override ,
             int is_default ) ;
void conf_report(void) ;
struct conf_trans_head conf_trans_queue  ;
u_int8_t const   bin2asc[65]  = 
  {      (u_int8_t const   )'A',      (u_int8_t const   )'B',      (u_int8_t const   )'C',      (u_int8_t const   )'D', 
        (u_int8_t const   )'E',      (u_int8_t const   )'F',      (u_int8_t const   )'G',      (u_int8_t const   )'H', 
        (u_int8_t const   )'I',      (u_int8_t const   )'J',      (u_int8_t const   )'K',      (u_int8_t const   )'L', 
        (u_int8_t const   )'M',      (u_int8_t const   )'N',      (u_int8_t const   )'O',      (u_int8_t const   )'P', 
        (u_int8_t const   )'Q',      (u_int8_t const   )'R',      (u_int8_t const   )'S',      (u_int8_t const   )'T', 
        (u_int8_t const   )'U',      (u_int8_t const   )'V',      (u_int8_t const   )'W',      (u_int8_t const   )'X', 
        (u_int8_t const   )'Y',      (u_int8_t const   )'Z',      (u_int8_t const   )'a',      (u_int8_t const   )'b', 
        (u_int8_t const   )'c',      (u_int8_t const   )'d',      (u_int8_t const   )'e',      (u_int8_t const   )'f', 
        (u_int8_t const   )'g',      (u_int8_t const   )'h',      (u_int8_t const   )'i',      (u_int8_t const   )'j', 
        (u_int8_t const   )'k',      (u_int8_t const   )'l',      (u_int8_t const   )'m',      (u_int8_t const   )'n', 
        (u_int8_t const   )'o',      (u_int8_t const   )'p',      (u_int8_t const   )'q',      (u_int8_t const   )'r', 
        (u_int8_t const   )'s',      (u_int8_t const   )'t',      (u_int8_t const   )'u',      (u_int8_t const   )'v', 
        (u_int8_t const   )'w',      (u_int8_t const   )'x',      (u_int8_t const   )'y',      (u_int8_t const   )'z', 
        (u_int8_t const   )'0',      (u_int8_t const   )'1',      (u_int8_t const   )'2',      (u_int8_t const   )'3', 
        (u_int8_t const   )'4',      (u_int8_t const   )'5',      (u_int8_t const   )'6',      (u_int8_t const   )'7', 
        (u_int8_t const   )'8',      (u_int8_t const   )'9',      (u_int8_t const   )'+',      (u_int8_t const   )'/', 
        (u_int8_t const   )'\000'};
u_int8_t const   asc2bin[128]  = 
  {      (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255, 
        (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255, 
        (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255, 
        (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255, 
        (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255, 
        (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255, 
        (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255, 
        (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255, 
        (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255, 
        (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255, 
        (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )62, 
        (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )63, 
        (u_int8_t const   )52,      (u_int8_t const   )53,      (u_int8_t const   )54,      (u_int8_t const   )55, 
        (u_int8_t const   )56,      (u_int8_t const   )57,      (u_int8_t const   )58,      (u_int8_t const   )59, 
        (u_int8_t const   )60,      (u_int8_t const   )61,      (u_int8_t const   )255,      (u_int8_t const   )255, 
        (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255, 
        (u_int8_t const   )255,      (u_int8_t const   )0,      (u_int8_t const   )1,      (u_int8_t const   )2, 
        (u_int8_t const   )3,      (u_int8_t const   )4,      (u_int8_t const   )5,      (u_int8_t const   )6, 
        (u_int8_t const   )7,      (u_int8_t const   )8,      (u_int8_t const   )9,      (u_int8_t const   )10, 
        (u_int8_t const   )11,      (u_int8_t const   )12,      (u_int8_t const   )13,      (u_int8_t const   )14, 
        (u_int8_t const   )15,      (u_int8_t const   )16,      (u_int8_t const   )17,      (u_int8_t const   )18, 
        (u_int8_t const   )19,      (u_int8_t const   )20,      (u_int8_t const   )21,      (u_int8_t const   )22, 
        (u_int8_t const   )23,      (u_int8_t const   )24,      (u_int8_t const   )25,      (u_int8_t const   )255, 
        (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255, 
        (u_int8_t const   )255,      (u_int8_t const   )26,      (u_int8_t const   )27,      (u_int8_t const   )28, 
        (u_int8_t const   )29,      (u_int8_t const   )30,      (u_int8_t const   )31,      (u_int8_t const   )32, 
        (u_int8_t const   )33,      (u_int8_t const   )34,      (u_int8_t const   )35,      (u_int8_t const   )36, 
        (u_int8_t const   )37,      (u_int8_t const   )38,      (u_int8_t const   )39,      (u_int8_t const   )40, 
        (u_int8_t const   )41,      (u_int8_t const   )42,      (u_int8_t const   )43,      (u_int8_t const   )44, 
        (u_int8_t const   )45,      (u_int8_t const   )46,      (u_int8_t const   )47,      (u_int8_t const   )48, 
        (u_int8_t const   )49,      (u_int8_t const   )50,      (u_int8_t const   )51,      (u_int8_t const   )255, 
        (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255,      (u_int8_t const   )255};
char *conf_path  =    (char *)"crawl.conf";
struct conf_bindings conf_bindings[256]  ;
static char *conf_addr  ;
__inline static u_int8_t conf_hash(char *s ) 
{ u_int8_t hash ;
  int tmp ;

  {
  hash = (u_int8_t )0;
  while (1) {
    if (*s) {

    } else {
      break;
    }
    tmp = tolower((int )*s);
    hash = (unsigned char )((((int )hash << 1) | ((int )hash >> 7)) ^ tmp);
    s = s + 1;
  }
  return (hash);
}
}
static int conf_remove_now(char *section___0 , char *tag ) 
{ struct conf_binding *cb ;
  struct conf_binding *next ;
  u_int8_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = conf_hash(section___0);
  cb = conf_bindings[tmp].lh_first;
  while (1) {
    if (cb) {

    } else {
      break;
    }
    next = cb->link.le_next;
    tmp___0 = strcasecmp((char const   *)cb->section, (char const   *)section___0);
    if (tmp___0 == 0) {
      tmp___1 = strcasecmp((char const   *)cb->tag, (char const   *)tag);
      if (tmp___1 == 0) {
        while (1) {
          if ((unsigned int )cb->link.le_next != (unsigned int )((void *)0)) {
            (cb->link.le_next)->link.le_prev = cb->link.le_prev;
          } else {

          }
          *(cb->link.le_prev) = cb->link.le_next;
          break;
        }
        free((void *)cb->section);
        free((void *)cb->tag);
        free((void *)cb->value);
        free((void *)cb);
        return (0);
      } else {

      }
    } else {

    }
    cb = next;
  }
  return (1);
}
}
static int conf_remove_section_now(char *section___0 ) 
{ struct conf_binding *cb ;
  struct conf_binding *next ;
  int unseen ;
  u_int8_t tmp ;
  int tmp___0 ;

  {
  unseen = 1;
  tmp = conf_hash(section___0);
  cb = conf_bindings[tmp].lh_first;
  while (1) {
    if (cb) {

    } else {
      break;
    }
    next = cb->link.le_next;
    tmp___0 = strcasecmp((char const   *)cb->section, (char const   *)section___0);
    if (tmp___0 == 0) {
      unseen = 0;
      while (1) {
        if ((unsigned int )cb->link.le_next != (unsigned int )((void *)0)) {
          (cb->link.le_next)->link.le_prev = cb->link.le_prev;
        } else {

        }
        *(cb->link.le_prev) = cb->link.le_next;
        break;
      }
      free((void *)cb->section);
      free((void *)cb->tag);
      free((void *)cb->value);
      free((void *)cb);
    } else {

    }
    cb = next;
  }
  return (unseen);
}
}
static int conf_set_now(char *section___0 , char *tag , char *value , int override ,
                        int is_default ) 
{ struct conf_binding *node ;
  char *tmp ;
  void *tmp___0 ;
  u_int8_t tmp___1 ;
  struct conf_binding *tmp___2 ;
  u_int8_t tmp___3 ;
  u_int8_t tmp___4 ;
  u_int8_t tmp___5 ;

  {
  node = (struct conf_binding *)0;
  if (override) {
    conf_remove_now(section___0, tag);
  } else {
    tmp = conf_get_str(section___0, tag);
    if (tmp) {
      if (! is_default) {
        warnx("conf_set: duplicate tag [%s]:%s, ignoring...\n", section___0, tag);
      } else {

      }
      return (1);
    } else {

    }
  }
  tmp___0 = calloc(1U, sizeof(*node));
  node = (struct conf_binding *)tmp___0;
  if (! node) {
    warn("conf_set: calloc (1, %d) failed", sizeof(*node));
    return (1);
  } else {

  }
  node->section = strdup((char const   *)section___0);
  node->tag = strdup((char const   *)tag);
  node->value = strdup((char const   *)value);
  node->is_default = is_default;
  while (1) {
    tmp___3 = conf_hash(section___0);
    tmp___2 = conf_bindings[tmp___3].lh_first;
    node->link.le_next = tmp___2;
    if ((unsigned int )tmp___2 != (unsigned int )((void *)0)) {
      tmp___1 = conf_hash(section___0);
      (conf_bindings[tmp___1].lh_first)->link.le_prev = & node->link.le_next;
    } else {

    }
    tmp___4 = conf_hash(section___0);
    conf_bindings[tmp___4].lh_first = node;
    tmp___5 = conf_hash(section___0);
    node->link.le_prev = & conf_bindings[tmp___5].lh_first;
    break;
  }
  return (0);
}
}
static void conf_parse_line(int trans , char *line , size_t sz ) ;
static char *section  =    (char *)0;
static int ln  =    0;
static void conf_parse_line(int trans , char *line , size_t sz ) 
{ char *cp ;
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  cp = line;
  ln = ln + 1;
  if ((int )*line == 35) {
    return;
  } else {
    if ((int )*line == 59) {
      return;
    } else {

    }
  }
  if ((int )*line == 91) {
    i = 1;
    while (1) {
      if ((size_t )i < sz) {

      } else {
        break;
      }
      if ((int )*(line + i) == 93) {
        break;
      } else {

      }
      i = i + 1;
    }
    if ((size_t )i == sz) {
      warnx("conf_parse_line: %d:non-matched \']\', ignoring until next section",
            ln);
      section = (char *)0;
      return;
    } else {

    }
    if (section) {
      free((void *)section);
    } else {

    }
    tmp = malloc((unsigned int )i);
    section = (char *)tmp;
    strncpy((char * __restrict  )section, (char const   * __restrict  )(line + 1),
            (unsigned int )(i - 1));
    *(section + (i - 1)) = (char )'\000';
    return;
  } else {

  }
  i = 0;
  while (1) {
    if ((size_t )i < sz) {

    } else {
      break;
    }
    if ((int )*(cp + i) == 61) {
      if (! section) {
        warnx("conf_parse_line: %d: ignoring line due to no section", ln);
        return;
      } else {

      }
      tmp___0 = strcspn((char const   *)line, " \t=");
      *(line + tmp___0) = (char )'\000';
      tmp___1 = strspn((char const   *)((line + i) + 1), " \t");
      conf_set(trans, section, line, ((line + i) + 1) + tmp___1, 0, 0);
      return;
    } else {

    }
    i = i + 1;
  }
  tmp___2 = strspn((char const   *)line, " \t");
  i = (int )tmp___2;
  if (*(line + i)) {
    warnx("conf_parse_line: %d: syntax error", ln);
  } else {

  }
  return;
}
}
static void conf_parse(int trans , char *buf , size_t sz ) 
{ char *cp ;
  char *bufend ;
  char *line ;
  char tmp ;

  {
  cp = buf;
  bufend = buf + sz;
  line = cp;
  while (1) {
    if ((unsigned int )cp < (unsigned int )bufend) {

    } else {
      break;
    }
    if ((int )*cp == 10) {
      if ((unsigned int )cp > (unsigned int )buf) {
        if ((int )*(cp - 1) == 92) {
          tmp = (char )' ';
          *cp = tmp;
          *(cp - 1) = tmp;
        } else {
          *cp = (char )'\000';
          conf_parse_line(trans, line, (unsigned int )(cp - line));
          line = cp + 1;
        }
      } else {
        *cp = (char )'\000';
        conf_parse_line(trans, line, (unsigned int )(cp - line));
        line = cp + 1;
      }
    } else {

    }
    cp = cp + 1;
  }
  if ((unsigned int )cp != (unsigned int )line) {
    warnx("conf_parse: last line non-terminated, ignored.");
  } else {

  }
  return;
}
}
void conf_load_defaults(int tr ) 
{ 

  {
  return;
}
}
void conf_init(void) 
{ int i ;

  {
  i = 0;
  while (1) {
    if ((unsigned int )i < sizeof(conf_bindings) / sizeof(conf_bindings[0])) {

    } else {
      break;
    }
    while (1) {
      conf_bindings[i].lh_first = (struct conf_binding *)((void *)0);
      break;
    }
    i = i + 1;
  }
  while (1) {
    conf_trans_queue.tqh_first = (struct conf_trans *)((void *)0);
    conf_trans_queue.tqh_last = & conf_trans_queue.tqh_first;
    break;
  }
  conf_reinit();
  return;
}
}
void conf_reinit(void) 
{ struct conf_binding *cb ;
  int fd ;
  int i ;
  int trans ;
  off_t sz ;
  char *new_conf_addr ;
  struct stat sb ;
  void *tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;

  {
  cb = (struct conf_binding *)0;
  new_conf_addr = (char *)0;
  tmp___1 = stat((char const   * __restrict  )conf_path, (struct stat * __restrict  )(& sb));
  if (tmp___1 == 0) {
    goto _L;
  } else {
    tmp___2 = __errno_location();
    if (*tmp___2 != 2) {
      _L: /* CIL Label */ 
      sz = sb.st_size;
      fd = open((char const   *)conf_path, 0);
      if (fd == -1) {
        warn("conf_reinit: open (\"%s\", O_RDONLY) failed", conf_path);
        return;
      } else {

      }
      tmp = malloc((unsigned int )sz);
      new_conf_addr = (char *)tmp;
      if (! new_conf_addr) {
        warn("conf_reinit: malloc (%d) failed", (int )sz);
        goto fail;
      } else {

      }
      tmp___0 = read(fd, (void *)new_conf_addr, (unsigned int )sz);
      if ((off_t )tmp___0 != sz) {
        warn("conf_reinit: read (%d, %p, %d) failed", fd, new_conf_addr, (int )sz);
        goto fail;
      } else {

      }
      close(fd);
      trans = conf_begin();
      conf_parse(trans, new_conf_addr, (unsigned int )sz);
    } else {
      trans = conf_begin();
    }
  }
  conf_load_defaults(trans);
  if (conf_addr) {
    i = 0;
    while (1) {
      if ((unsigned int )i < sizeof(conf_bindings) / sizeof(conf_bindings[0])) {

      } else {
        break;
      }
      cb = conf_bindings[i].lh_first;
      while (1) {
        if (cb) {

        } else {
          break;
        }
        conf_remove_now(cb->section, cb->tag);
        cb = conf_bindings[i].lh_first;
      }
      i = i + 1;
    }
    free((void *)conf_addr);
  } else {

  }
  conf_end(trans, 1);
  conf_addr = new_conf_addr;
  return;
  fail: 
  if (new_conf_addr) {
    free((void *)new_conf_addr);
  } else {

  }
  close(fd);
  return;
}
}
int conf_get_num(char *section___0 , char *tag , int def ) 
{ char *value ;
  char *tmp ;
  int tmp___0 ;

  {
  tmp = conf_get_str(section___0, tag);
  value = tmp;
  if (value) {
    tmp___0 = atoi((char const   *)value);
    return (tmp___0);
  } else {

  }
  return (def);
}
}
int conf_match_num(char *section___0 , char *tag , int x ) 
{ char *value ;
  char *tmp ;
  int val ;
  int min ;
  int max ;
  int n ;
  int tmp___0 ;

  {
  tmp = conf_get_str(section___0, tag);
  value = tmp;
  if (! value) {
    return (0);
  } else {

  }
  n = sscanf((char const   * __restrict  )value, (char const   * __restrict  )"%d,%d:%d",
             & val, & min, & max);
  switch (n) {
  case 1: 
  return (x == val);
  case 3: 
  if (min <= x) {
    if (max >= x) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
  default: 
  warn("conf_match_num: section %s tag %s: invalid number spec %s", section___0, tag,
       value);
  }
  return (0);
}
}
char *conf_get_str(char *section___0 , char *tag ) 
{ struct conf_binding *cb ;
  u_int8_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = conf_hash(section___0);
  cb = conf_bindings[tmp].lh_first;
  while (1) {
    if (cb) {

    } else {
      break;
    }
    tmp___0 = strcasecmp((char const   *)section___0, (char const   *)cb->section);
    if (tmp___0 == 0) {
      tmp___1 = strcasecmp((char const   *)tag, (char const   *)cb->tag);
      if (tmp___1 == 0) {
        return (cb->value);
      } else {

      }
    } else {

    }
    cb = cb->link.le_next;
  }
  return ((char *)0);
}
}
struct conf_list *conf_get_list(char *section___0 , char *tag ) 
{ char *liststr ;
  char *p ;
  char *field ;
  struct conf_list *list ;
  struct conf_list_node *node ;
  void *tmp ;
  void *tmp___0 ;

  {
  liststr = (char *)0;
  list = (struct conf_list *)0;
  tmp = malloc(sizeof(*list));
  list = (struct conf_list *)tmp;
  if (! list) {
    goto cleanup;
  } else {

  }
  while (1) {
    list->fields.tqh_first = (struct conf_list_node *)((void *)0);
    list->fields.tqh_last = & list->fields.tqh_first;
    break;
  }
  list->cnt = 0;
  liststr = conf_get_str(section___0, tag);
  if (! liststr) {
    goto cleanup;
  } else {

  }
  liststr = strdup((char const   *)liststr);
  if (! liststr) {
    goto cleanup;
  } else {

  }
  p = liststr;
  while (1) {
    field = strsep((char ** __restrict  )(& p), (char const   * __restrict  )", \t");
    if ((unsigned int )field != (unsigned int )((void *)0)) {

    } else {
      break;
    }
    if ((int )*field == 0) {
      warnx("conf_get_list: empty field, ignoring...");
      continue;
    } else {

    }
    list->cnt = list->cnt + 1;
    tmp___0 = calloc(1U, sizeof(*node));
    node = (struct conf_list_node *)tmp___0;
    if (! node) {
      goto cleanup;
    } else {

    }
    node->field = strdup((char const   *)field);
    if (! node->field) {
      goto cleanup;
    } else {

    }
    while (1) {
      node->link.tqe_next = (struct conf_list_node *)((void *)0);
      node->link.tqe_prev = list->fields.tqh_last;
      *(list->fields.tqh_last) = node;
      list->fields.tqh_last = & node->link.tqe_next;
      break;
    }
  }
  free((void *)liststr);
  return (list);
  cleanup: 
  if (list) {
    conf_free_list(list);
  } else {

  }
  if (liststr) {
    free((void *)liststr);
  } else {

  }
  return ((struct conf_list *)0);
}
}
struct conf_list *conf_get_tag_list(char *section___0 ) 
{ struct conf_list *list ;
  struct conf_list_node *node ;
  struct conf_binding *cb ;
  void *tmp ;
  u_int8_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  list = (struct conf_list *)0;
  tmp = malloc(sizeof(*list));
  list = (struct conf_list *)tmp;
  if (! list) {
    goto cleanup;
  } else {

  }
  while (1) {
    list->fields.tqh_first = (struct conf_list_node *)((void *)0);
    list->fields.tqh_last = & list->fields.tqh_first;
    break;
  }
  list->cnt = 0;
  tmp___0 = conf_hash(section___0);
  cb = conf_bindings[tmp___0].lh_first;
  while (1) {
    if (cb) {

    } else {
      break;
    }
    tmp___2 = strcasecmp((char const   *)section___0, (char const   *)cb->section);
    if (tmp___2 == 0) {
      list->cnt = list->cnt + 1;
      tmp___1 = calloc(1U, sizeof(*node));
      node = (struct conf_list_node *)tmp___1;
      if (! node) {
        goto cleanup;
      } else {

      }
      node->field = strdup((char const   *)cb->tag);
      if (! node->field) {
        goto cleanup;
      } else {

      }
      while (1) {
        node->link.tqe_next = (struct conf_list_node *)((void *)0);
        node->link.tqe_prev = list->fields.tqh_last;
        *(list->fields.tqh_last) = node;
        list->fields.tqh_last = & node->link.tqe_next;
        break;
      }
    } else {

    }
    cb = cb->link.le_next;
  }
  return (list);
  cleanup: 
  if (list) {
    conf_free_list(list);
  } else {

  }
  return ((struct conf_list *)0);
}
}
int conf_decode_base64(u_int8_t *out , u_int32_t *len , u_char *buf ) 
{ u_int32_t c ;
  u_int8_t c1 ;
  u_int8_t c2 ;
  u_int8_t c3 ;
  u_int8_t c4 ;
  int tmp ;
  int tmp___0 ;
  u_int8_t *tmp___1 ;
  u_int8_t *tmp___2 ;
  u_int8_t *tmp___3 ;

  {
  c = (u_int32_t )0;
  while (1) {
    if (*buf) {

    } else {
      break;
    }
    if ((int )*buf > 127) {
      return (0);
    } else {
      c1 = (unsigned char )asc2bin[*buf];
      if ((int )c1 == 255) {
        return (0);
      } else {

      }
    }
    buf = buf + 1;
    if ((int )*buf > 127) {
      return (0);
    } else {
      c2 = (unsigned char )asc2bin[*buf];
      if ((int )c2 == 255) {
        return (0);
      } else {

      }
    }
    buf = buf + 1;
    if ((int )*buf == 61) {
      c4 = (unsigned char)0;
      c3 = c4;
      c = c + 1U;
      if ((int )c2 & 15) {
        return (0);
      } else {

      }
      tmp = strcmp((char const   *)buf, "==");
      if (tmp) {
        return (0);
      } else {
        buf = buf + 1;
      }
    } else {
      if ((int )*buf > 127) {
        return (0);
      } else {
        c3 = (unsigned char )asc2bin[*buf];
        if ((int )c3 == 255) {
          return (0);
        } else {
          buf = buf + 1;
          if ((int )*buf == 61) {
            c4 = (unsigned char)0;
            c = c + 2U;
            if ((int )c3 & 3) {
              return (0);
            } else {

            }
            tmp___0 = strcmp((char const   *)buf, "=");
            if (tmp___0) {
              return (0);
            } else {

            }
          } else {
            if ((int )*buf > 127) {
              return (0);
            } else {
              c4 = (unsigned char )asc2bin[*buf];
              if ((int )c4 == 255) {
                return (0);
              } else {
                c = c + 3U;
              }
            }
          }
        }
      }
    }
    buf = buf + 1;
    tmp___1 = out;
    out = out + 1;
    *tmp___1 = (unsigned char )(((int )c1 << 2) | ((int )c2 >> 4));
    tmp___2 = out;
    out = out + 1;
    *tmp___2 = (unsigned char )(((int )c2 << 4) | ((int )c3 >> 2));
    tmp___3 = out;
    out = out + 1;
    *tmp___3 = (unsigned char )(((int )c3 << 6) | (int )c4);
  }
  *len = c;
  return (1);
}
}
int conf_get_line(FILE *stream , char *buf , u_int32_t len ) 
{ int c ;
  char *tmp ;
  u_int32_t tmp___0 ;

  {
  while (1) {
    tmp___0 = len;
    len = len - 1U;
    if (tmp___0 > 1U) {

    } else {
      break;
    }
    c = fgetc(stream);
    if (c == 10) {
      *buf = (char)0;
      return (1);
    } else {
      if (c == -1) {
        break;
      } else {

      }
    }
    tmp = buf;
    buf = buf + 1;
    *tmp = (char )c;
  }
  *buf = (char)0;
  return (0);
}
}
void conf_free_list(struct conf_list *list ) 
{ struct conf_list_node *node ;

  {
  node = list->fields.tqh_first;
  while (1) {
    if (node) {

    } else {
      break;
    }
    while (1) {
      if ((unsigned int )node->link.tqe_next != (unsigned int )((void *)0)) {
        (node->link.tqe_next)->link.tqe_prev = node->link.tqe_prev;
      } else {
        list->fields.tqh_last = node->link.tqe_prev;
      }
      *(node->link.tqe_prev) = node->link.tqe_next;
      break;
    }
    if (node->field) {
      free((void *)node->field);
    } else {

    }
    free((void *)node);
    node = list->fields.tqh_first;
  }
  free((void *)list);
  return;
}
}
static int seq  =    0;
int conf_begin(void) 
{ 

  {
  seq = seq + 1;
  return (seq);
}
}
static struct conf_trans *conf_trans_node(int transaction , enum conf_op op ) 
{ struct conf_trans *node ;
  void *tmp ;

  {
  tmp = calloc(1U, sizeof(*node));
  node = (struct conf_trans *)tmp;
  if (! node) {
    warn("conf_trans_node: calloc (1, %d) failed", sizeof(*node));
    return ((struct conf_trans *)0);
  } else {

  }
  node->trans = transaction;
  node->op = op;
  while (1) {
    node->link.tqe_next = (struct conf_trans *)((void *)0);
    node->link.tqe_prev = conf_trans_queue.tqh_last;
    *(conf_trans_queue.tqh_last) = node;
    conf_trans_queue.tqh_last = & node->link.tqe_next;
    break;
  }
  return (node);
}
}
int conf_set(int transaction , char *section___0 , char *tag , char *value , int override ,
             int is_default ) 
{ struct conf_trans *node ;

  {
  node = conf_trans_node(transaction, 0);
  if (! node) {
    return (1);
  } else {

  }
  node->section = strdup((char const   *)section___0);
  if (! node->section) {
    warn("conf_set: strdup (\"%s\") failed", section___0);
    goto fail;
  } else {

  }
  node->tag = strdup((char const   *)tag);
  if (! node->tag) {
    warn("conf_set: strdup (\"%s\") failed", tag);
    goto fail;
  } else {

  }
  node->value = strdup((char const   *)value);
  if (! node->value) {
    warn("conf_set: strdup (\"%s\") failed", value);
    goto fail;
  } else {

  }
  node->override = override;
  node->is_default = is_default;
  return (0);
  fail: 
  if (node->tag) {
    free((void *)node->tag);
  } else {

  }
  if (node->section) {
    free((void *)node->section);
  } else {

  }
  if (node) {
    free((void *)node);
  } else {

  }
  return (1);
}
}
int conf_remove(int transaction , char *section___0 , char *tag ) 
{ struct conf_trans *node ;

  {
  node = conf_trans_node(transaction, 1);
  if (! node) {
    goto fail;
  } else {

  }
  node->section = strdup((char const   *)section___0);
  if (! node->section) {
    warn("conf_remove: strdup (\"%s\") failed", section___0);
    goto fail;
  } else {

  }
  node->tag = strdup((char const   *)tag);
  if (! node->tag) {
    warn("conf_remove: strdup (\"%s\") failed", tag);
    goto fail;
  } else {

  }
  return (0);
  fail: 
  if (node->section) {
    free((void *)node->section);
  } else {

  }
  if (node) {
    free((void *)node);
  } else {

  }
  return (1);
}
}
int conf_remove_section(int transaction , char *section___0 ) 
{ struct conf_trans *node ;

  {
  node = conf_trans_node(transaction, 2);
  if (! node) {
    goto fail;
  } else {

  }
  node->section = strdup((char const   *)section___0);
  if (! node->section) {
    warn("conf_remove_section: strdup (\"%s\") failed", section___0);
    goto fail;
  } else {

  }
  return (0);
  fail: 
  if (node) {
    free((void *)node);
  } else {

  }
  return (1);
}
}
int conf_end(int transaction , int commit ) 
{ struct conf_trans *node ;
  struct conf_trans *next ;

  {
  node = conf_trans_queue.tqh_first;
  while (1) {
    if (node) {

    } else {
      break;
    }
    next = node->link.tqe_next;
    if (node->trans == transaction) {
      if (commit) {
        switch ((int )node->op) {
        case 0: 
        conf_set_now(node->section, node->tag, node->value, node->override, node->is_default);
        break;
        case 1: 
        conf_remove_now(node->section, node->tag);
        break;
        case 2: 
        conf_remove_section_now(node->section);
        break;
        default: 
        warnx("conf_end: unknown operation: %d", node->op);
        }
      } else {

      }
      while (1) {
        if ((unsigned int )node->link.tqe_next != (unsigned int )((void *)0)) {
          (node->link.tqe_next)->link.tqe_prev = node->link.tqe_prev;
        } else {
          conf_trans_queue.tqh_last = node->link.tqe_prev;
        }
        *(node->link.tqe_prev) = node->link.tqe_next;
        break;
      }
      if (node->section) {
        free((void *)node->section);
      } else {

      }
      if (node->tag) {
        free((void *)node->tag);
      } else {

      }
      if (node->value) {
        free((void *)node->value);
      } else {

      }
      free((void *)node);
    } else {

    }
    node = next;
  }
  return (0);
}
}
static void conf_report_dump(struct dumper *node ) 
{ size_t tmp ;

  {
  if (node->next) {
    conf_report_dump(node->next);
  } else {

  }
  if (node->v) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s=\t%s", node->s,
            node->v);
  } else {
    if (node->s) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", node->s);
      tmp = strlen((char const   *)node->s);
      if (tmp > 0U) {
        free((void *)node->s);
      } else {

      }
    } else {

    }
  }
  free((void *)node);
  return;
}
}
void conf_report(void) 
{ struct conf_binding *cb ;
  struct conf_binding *last ;
  int i ;
  char *current_section ;
  struct dumper *dumper ;
  struct dumper *dnode ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;

  {
  last = (struct conf_binding *)((void *)0);
  current_section = (char *)0;
  tmp = calloc(1U, sizeof(*dumper));
  dnode = (struct dumper *)tmp;
  dumper = dnode;
  if (! dumper) {
    goto mem_fail;
  } else {

  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"conf_report: dumping running configuration");
  i = 0;
  while (1) {
    if ((unsigned int )i < sizeof(conf_bindings) / sizeof(conf_bindings[0])) {

    } else {
      break;
    }
    cb = conf_bindings[i].lh_first;
    while (1) {
      if (cb) {

      } else {
        break;
      }
      if (! cb->is_default) {
        if (! current_section) {
          goto _L;
        } else {
          tmp___4 = strcmp((char const   *)cb->section, (char const   *)current_section);
          if (tmp___4) {
            _L: /* CIL Label */ 
            if (current_section) {
              tmp___0 = strlen((char const   *)current_section);
              tmp___1 = malloc(tmp___0 + 3U);
              dnode->s = (char *)tmp___1;
              if (! dnode->s) {
                goto mem_fail;
              } else {

              }
              sprintf((char * __restrict  )dnode->s, (char const   * __restrict  )"[%s]",
                      current_section);
              tmp___2 = calloc(1U, sizeof(struct dumper ));
              dnode->next = (struct dumper *)tmp___2;
              dnode = dnode->next;
              if (! dnode) {
                goto mem_fail;
              } else {

              }
              dnode->s = (char *)"";
              tmp___3 = calloc(1U, sizeof(struct dumper ));
              dnode->next = (struct dumper *)tmp___3;
              dnode = dnode->next;
              if (! dnode) {
                goto mem_fail;
              } else {

              }
            } else {

            }
            current_section = cb->section;
          } else {

          }
        }
        dnode->s = cb->tag;
        dnode->v = cb->value;
        tmp___5 = calloc(1U, sizeof(struct dumper ));
        dnode->next = (struct dumper *)tmp___5;
        dnode = dnode->next;
        if (! dnode) {
          goto mem_fail;
        } else {

        }
        last = cb;
      } else {

      }
      cb = cb->link.le_next;
    }
    i = i + 1;
  }
  if (last) {
    tmp___6 = strlen((char const   *)last->section);
    tmp___7 = malloc(tmp___6 + 3U);
    dnode->s = (char *)tmp___7;
    if (! dnode->s) {
      goto mem_fail;
    } else {

    }
    sprintf((char * __restrict  )dnode->s, (char const   * __restrict  )"[%s]", last->section);
  } else {

  }
  conf_report_dump(dumper);
  return;
  mem_fail: 
  warn("conf_report: memory allocation failure.");
  while (1) {
    dnode = dumper;
    if ((unsigned int )dnode != (unsigned int )((void *)0)) {

    } else {
      break;
    }
    dumper = dumper->next;
    if (dnode->s) {
      free((void *)dnode->s);
    } else {

    }
    free((void *)dnode);
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-acepf8xT.i","-Wall")
void http_robots_listfree(char **list ) ;
void http_robots_free(struct http_robots *htrobot ) ;
struct rtree robottree  ;
struct stats___1 robot_stats  ;
static int compare___0(struct http_robots *a , struct http_robots *b ) 
{ int tmp ;

  {
  robot_stats.iterations = robot_stats.iterations + 1U;
  tmp = strcmp((char const   *)a->host, (char const   *)b->host);
  return (tmp);
}
}
void rtree_SPLAY(struct rtree *head , struct http_robots *elm ) ;
void rtree_SPLAY_MINMAX(struct rtree *head , int __comp ) ;
__inline static void rtree_SPLAY_INSERT(struct rtree *head , struct http_robots *elm ) 
{ struct http_robots *tmp ;
  int __comp ;

  {
  if ((unsigned int )head->sph_root == (unsigned int )((void *)0)) {
    tmp = (struct http_robots *)((void *)0);
    elm->splay_next.spe_right = tmp;
    elm->splay_next.spe_left = tmp;
  } else {
    rtree_SPLAY(head, elm);
    __comp = compare___0(elm, head->sph_root);
    if (__comp < 0) {
      elm->splay_next.spe_left = (head->sph_root)->splay_next.spe_left;
      elm->splay_next.spe_right = head->sph_root;
      (head->sph_root)->splay_next.spe_left = (struct http_robots *)((void *)0);
    } else {
      if (__comp > 0) {
        elm->splay_next.spe_right = (head->sph_root)->splay_next.spe_right;
        elm->splay_next.spe_left = head->sph_root;
        (head->sph_root)->splay_next.spe_right = (struct http_robots *)((void *)0);
      } else {
        return;
      }
    }
  }
  head->sph_root = elm;
  return;
}
}
__inline static void rtree_SPLAY_REMOVE(struct rtree *head , struct http_robots *elm ) 
{ struct http_robots *__tmp ;
  int tmp ;

  {
  if ((unsigned int )head->sph_root == (unsigned int )((void *)0)) {
    return;
  } else {

  }
  rtree_SPLAY(head, elm);
  tmp = compare___0(elm, head->sph_root);
  if (tmp == 0) {
    if ((unsigned int )(head->sph_root)->splay_next.spe_left == (unsigned int )((void *)0)) {
      head->sph_root = (head->sph_root)->splay_next.spe_right;
    } else {
      __tmp = (head->sph_root)->splay_next.spe_right;
      head->sph_root = (head->sph_root)->splay_next.spe_left;
      rtree_SPLAY(head, elm);
      (head->sph_root)->splay_next.spe_right = __tmp;
    }
  } else {

  }
  return;
}
}
__inline static struct http_robots *rtree_SPLAY_FIND(struct rtree *head , struct http_robots *elm ) 
{ int tmp ;

  {
  if ((unsigned int )head->sph_root == (unsigned int )((void *)0)) {
    return ((struct http_robots *)((void *)0));
  } else {

  }
  rtree_SPLAY(head, elm);
  tmp = compare___0(elm, head->sph_root);
  if (tmp == 0) {
    return (head->sph_root);
  } else {

  }
  return ((struct http_robots *)((void *)0));
}
}
void rtree_SPLAY(struct rtree *head , struct http_robots *elm ) 
{ struct http_robots __node ;
  struct http_robots *__left ;
  struct http_robots *__right ;
  struct http_robots *__tmp ;
  int __comp ;
  int tmp ;
  int tmp___0 ;

  {
  __node.splay_next.spe_right = (struct http_robots *)((void *)0);
  __node.splay_next.spe_left = __node.splay_next.spe_right;
  __right = & __node;
  __left = __right;
  while (1) {
    __comp = compare___0(elm, head->sph_root);
    if (__comp) {

    } else {
      break;
    }
    if (__comp < 0) {
      if ((unsigned int )(head->sph_root)->splay_next.spe_left == (unsigned int )((void *)0)) {
        break;
      } else {

      }
      tmp = compare___0(elm, (head->sph_root)->splay_next.spe_left);
      if (tmp < 0) {
        while (1) {
          __tmp = (head->sph_root)->splay_next.spe_left;
          (head->sph_root)->splay_next.spe_left = __tmp->splay_next.spe_right;
          __tmp->splay_next.spe_right = head->sph_root;
          head->sph_root = __tmp;
          break;
        }
        if ((unsigned int )(head->sph_root)->splay_next.spe_left == (unsigned int )((void *)0)) {
          break;
        } else {

        }
      } else {

      }
      while (1) {
        __right->splay_next.spe_left = head->sph_root;
        __right = head->sph_root;
        head->sph_root = (head->sph_root)->splay_next.spe_left;
        break;
      }
    } else {
      if (__comp > 0) {
        if ((unsigned int )(head->sph_root)->splay_next.spe_right == (unsigned int )((void *)0)) {
          break;
        } else {

        }
        tmp___0 = compare___0(elm, (head->sph_root)->splay_next.spe_right);
        if (tmp___0 > 0) {
          while (1) {
            __tmp = (head->sph_root)->splay_next.spe_right;
            (head->sph_root)->splay_next.spe_right = __tmp->splay_next.spe_left;
            __tmp->splay_next.spe_left = head->sph_root;
            head->sph_root = __tmp;
            break;
          }
          if ((unsigned int )(head->sph_root)->splay_next.spe_right == (unsigned int )((void *)0)) {
            break;
          } else {

          }
        } else {

        }
        while (1) {
          __left->splay_next.spe_right = head->sph_root;
          __left = head->sph_root;
          head->sph_root = (head->sph_root)->splay_next.spe_right;
          break;
        }
      } else {

      }
    }
  }
  while (1) {
    __left->splay_next.spe_right = (head->sph_root)->splay_next.spe_left;
    __right->splay_next.spe_left = (head->sph_root)->splay_next.spe_right;
    (head->sph_root)->splay_next.spe_left = __node.splay_next.spe_right;
    (head->sph_root)->splay_next.spe_right = __node.splay_next.spe_left;
    break;
  }
  return;
}
}
void rtree_SPLAY_MINMAX(struct rtree *head , int __comp ) 
{ struct http_robots __node ;
  struct http_robots *__left ;
  struct http_robots *__right ;
  struct http_robots *__tmp ;

  {
  __node.splay_next.spe_right = (struct http_robots *)((void *)0);
  __node.splay_next.spe_left = __node.splay_next.spe_right;
  __right = & __node;
  __left = __right;
  while (1) {
    if (__comp < 0) {
      if ((unsigned int )(head->sph_root)->splay_next.spe_left == (unsigned int )((void *)0)) {
        break;
      } else {

      }
      if (__comp < 0) {
        while (1) {
          __tmp = (head->sph_root)->splay_next.spe_left;
          (head->sph_root)->splay_next.spe_left = __tmp->splay_next.spe_right;
          __tmp->splay_next.spe_right = head->sph_root;
          head->sph_root = __tmp;
          break;
        }
        if ((unsigned int )(head->sph_root)->splay_next.spe_left == (unsigned int )((void *)0)) {
          break;
        } else {

        }
      } else {

      }
      while (1) {
        __right->splay_next.spe_left = head->sph_root;
        __right = head->sph_root;
        head->sph_root = (head->sph_root)->splay_next.spe_left;
        break;
      }
    } else {
      if (__comp > 0) {
        if ((unsigned int )(head->sph_root)->splay_next.spe_right == (unsigned int )((void *)0)) {
          break;
        } else {

        }
        if (__comp > 0) {
          while (1) {
            __tmp = (head->sph_root)->splay_next.spe_right;
            (head->sph_root)->splay_next.spe_right = __tmp->splay_next.spe_left;
            __tmp->splay_next.spe_left = head->sph_root;
            head->sph_root = __tmp;
            break;
          }
          if ((unsigned int )(head->sph_root)->splay_next.spe_right == (unsigned int )((void *)0)) {
            break;
          } else {

          }
        } else {

        }
        while (1) {
          __left->splay_next.spe_right = head->sph_root;
          __left = head->sph_root;
          head->sph_root = (head->sph_root)->splay_next.spe_right;
          break;
        }
      } else {

      }
    }
  }
  while (1) {
    __left->splay_next.spe_right = (head->sph_root)->splay_next.spe_left;
    __right->splay_next.spe_left = (head->sph_root)->splay_next.spe_right;
    (head->sph_root)->splay_next.spe_left = __node.splay_next.spe_right;
    (head->sph_root)->splay_next.spe_right = __node.splay_next.spe_left;
    break;
  }
  return;
}
}
struct robots_list robotsqueue  ;
int robotsentries  ;
void http_robots_init(void) 
{ 

  {
  while (1) {
    robottree.sph_root = (struct http_robots *)((void *)0);
    break;
  }
  while (1) {
    robotsqueue.tqh_first = (struct http_robots *)((void *)0);
    robotsqueue.tqh_last = & robotsqueue.tqh_first;
    break;
  }
  robotsentries = 0;
  memset((void *)(& robot_stats), 0, sizeof(robot_stats));
  return;
}
}
void http_robots_print_stats(void) 
{ 

  {
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Robots.txt inspected: %d\n",
          robot_stats.robotfiles);
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"  matched useragent %d times\n",
          robot_stats.matches);
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"  replaced %d entries\n",
          robot_stats.replacements);
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"  rejected %d requests\n",
          robot_stats.rejects);
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"  average list search: %f\n",
          (float )robot_stats.iterations / (float )robot_stats.calls);
  return;
}
}
struct http_robots *http_robots_new(char *host___0 , u_short port ) 
{ struct http_robots *htrobot ;
  void *tmp ;
  struct http_robots *tmp___0 ;
  struct http_robots *tmp___1 ;

  {
  tmp = calloc(1U, sizeof(struct http_robots ));
  htrobot = (struct http_robots *)tmp;
  if ((unsigned int )htrobot == (unsigned int )((void *)0)) {
    warn("%s: calloc", "http_robots_new");
    return ((struct http_robots *)((void *)0));
  } else {

  }
  htrobot->host = strdup((char const   *)host___0);
  if ((unsigned int )htrobot->host == (unsigned int )((void *)0)) {
    free((void *)htrobot);
    warn("%s: strdup", "http_robots_new");
    return ((struct http_robots *)((void *)0));
  } else {

  }
  htrobot->port = port;
  htrobot->flags = 1;
  while (1) {
    tmp___0 = robotsqueue.tqh_first;
    htrobot->robot_next.tqe_next = tmp___0;
    if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
      (robotsqueue.tqh_first)->robot_next.tqe_prev = & htrobot->robot_next.tqe_next;
    } else {
      robotsqueue.tqh_last = & htrobot->robot_next.tqe_next;
    }
    robotsqueue.tqh_first = htrobot;
    htrobot->robot_next.tqe_prev = & robotsqueue.tqh_first;
    break;
  }
  rtree_SPLAY_INSERT(& robottree, htrobot);
  if (robotsentries > 32768) {
    tmp___1 = *(((struct robots_list *)robotsqueue.tqh_last)->tqh_last);
    http_robots_free(tmp___1);
    robot_stats.replacements = robot_stats.replacements + 1U;
  } else {

  }
  robotsentries = robotsentries + 1;
  return (htrobot);
}
}
void http_robots_free(struct http_robots *htrobot ) 
{ 

  {
  while (1) {
    if ((unsigned int )htrobot->robot_next.tqe_next != (unsigned int )((void *)0)) {
      (htrobot->robot_next.tqe_next)->robot_next.tqe_prev = htrobot->robot_next.tqe_prev;
    } else {
      robotsqueue.tqh_last = htrobot->robot_next.tqe_prev;
    }
    *(htrobot->robot_next.tqe_prev) = htrobot->robot_next.tqe_next;
    break;
  }
  rtree_SPLAY_REMOVE(& robottree, htrobot);
  if (htrobot->dislist) {
    http_robots_listfree(htrobot->dislist);
  } else {

  }
  free((void *)htrobot->host);
  free((void *)htrobot);
  robotsentries = robotsentries - 1;
  return;
}
}
int http_robots_get(char *host___0 , u_short port ) 
{ struct http_robots *htrobot ;
  struct uri *uri ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  uri = uri_new();
  if ((unsigned int )uri == (unsigned int )((void *)0)) {
    return (-1);
  } else {

  }
  tmp = strdup((char const   *)host___0);
  uri->url.host = tmp;
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
    uri_free(uri, 0);
    return (-1);
  } else {

  }
  uri->url.port = port;
  tmp___0 = strdup("/robots.txt");
  uri->url.file = tmp___0;
  if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
    uri_free(uri, 0);
    return (-1);
  } else {

  }
  htrobot = http_robots_new(host___0, port);
  if ((unsigned int )htrobot == (unsigned int )((void *)0)) {
    uri_free(uri, 0);
    return (-1);
  } else {

  }
  tmp___1 = http_newconnection(uri, host___0, port);
  if (tmp___1 == -1) {
    goto fail;
  } else {

  }
  uri->flags = (unsigned short)1;
  uri->depth = (unsigned short)65535;
  return (0);
  fail: 
  http_robots_free(htrobot);
  uri_free(uri, 1);
  return (-1);
}
}
struct http_robots *http_robots_find(char *host___0 , u_short port ) 
{ struct http_robots *tmp ;
  struct http_robots tmp2 ;

  {
  tmp2.host = host___0;
  robot_stats.calls = robot_stats.calls + 1U;
  tmp = rtree_SPLAY_FIND(& robottree, & tmp2);
  return (tmp);
}
}
int http_robots_allow(struct http_robots *htrobot , char *file___0 ) 
{ char **p ;
  size_t tmp ;
  int tmp___0 ;

  {
  p = htrobot->dislist;
  if ((unsigned int )p == (unsigned int )((void *)0)) {
    return (1);
  } else {

  }
  while (1) {
    if (*p) {

    } else {
      break;
    }
    tmp = strlen((char const   *)*p);
    tmp___0 = strncasecmp((char const   *)file___0, (char const   *)*p, tmp);
    if (tmp___0) {

    } else {
      robot_stats.rejects = robot_stats.rejects + 1U;
      return (0);
    }
    p = p + 1;
  }
  return (1);
}
}
void http_robots_listfree(char **list ) 
{ char **p ;

  {
  p = list;
  while (1) {
    if (*p) {

    } else {
      break;
    }
    free((void *)*p);
    p = p + 1;
  }
  free((void *)list);
  return;
}
}
void http_robots_response(struct uri *uri ) 
{ char *p ;
  char *end ;
  char *lend ;
  int flag ;
  int ualen ;
  int tmpentries ;
  struct http_robots *htrobot ;
  char **tmplist ;
  char *where ;
  size_t tmp ;
  size_t tmp___0 ;
  char *pa ;
  char *pe ;
  char **tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  char *tmp___12 ;

  {
  ualen = 0;
  htrobot = http_robots_find(uri->url.host, uri->url.port);
  if ((unsigned int )htrobot == (unsigned int )((void *)0)) {
    return;
  } else {
    if (! (htrobot->flags & 1)) {
      return;
    } else {

    }
  }
  robot_stats.robotfiles = robot_stats.robotfiles + 1U;
  htrobot->flags = htrobot->flags & -2;
  if (uri->bdlen == 0U) {
    return;
  } else {
    if (uri->code == 404) {
      return;
    } else {

    }
  }
  if ((unsigned int )rawname != (unsigned int )((void *)0)) {
    where = strchr((char const   *)rawname, '/');
    if ((unsigned int )where != (unsigned int )((void *)0)) {
      ualen = where - rawname;
    } else {
      tmp = strlen((char const   *)rawname);
      ualen = (int )tmp;
    }
  } else {

  }
  p = uri->body;
  end = p + uri->bdlen;
  flag = 1;
  tmplist = (char **)((void *)0);
  tmpentries = 1;
  while (1) {
    if ((unsigned int )p < (unsigned int )end) {

    } else {
      break;
    }
    lend = strpbrk((char const   *)p, "\r\n");
    if ((unsigned int )lend == (unsigned int )((void *)0)) {
      lend = end;
    } else {

    }
    tmp___5 = strlen("User-Agent:");
    tmp___6 = strncasecmp((char const   *)p, "User-Agent:", tmp___5);
    if (tmp___6) {

    } else {
      tmp___2 = strlen("User-Agent:");
      pa = p + tmp___2;
      tmp___3 = strspn((char const   *)pa, " \t");
      pa = pa + tmp___3;
      if ((unsigned int )tmplist != (unsigned int )((void *)0)) {
        if ((unsigned int )htrobot->dislist != (unsigned int )((void *)0)) {
          http_robots_listfree(htrobot->dislist);
        } else {

        }
        htrobot->dislist = tmplist;
        tmplist = (char **)((void *)0);
        tmpentries = 1;
      } else {

      }
      if ((int )*pa != 42) {
        if ((unsigned int )rawname == (unsigned int )((void *)0)) {
          flag = flag | 1;
          goto __Cont;
        } else {
          tmp___4 = strncasecmp((char const   *)pa, (char const   *)rawname, (unsigned int )ualen);
          if (tmp___4) {
            flag = flag | 1;
            goto __Cont;
          } else {

          }
        }
        flag = flag | 2;
      } else {
        if (flag & 2) {
          flag = flag | 1;
          goto __Cont;
        } else {

        }
      }
      flag = flag & -2;
      if ((unsigned int )htrobot->dislist != (unsigned int )((void *)0)) {
        http_robots_listfree(htrobot->dislist);
        htrobot->dislist = (char **)((void *)0);
      } else {

      }
      robot_stats.matches = robot_stats.matches + 1U;
    }
    if (flag & 1) {
      goto __Cont;
    } else {

    }
    tmp___7 = strlen("Disallow:");
    tmp___8 = strncasecmp((char const   *)p, "Disallow:", tmp___7);
    if (tmp___8) {
      goto __Cont;
    } else {

    }
    tmp___9 = strlen("Disallow:");
    pa = p + tmp___9;
    tmp___10 = strspn((char const   *)pa, " \t");
    pa = pa + tmp___10;
    pe = strpbrk((char const   *)pa, " \t\r\n");
    if ((unsigned int )pe == (unsigned int )pa) {
      flag = flag | 1;
      if ((unsigned int )tmplist != (unsigned int )((void *)0)) {
        http_robots_listfree(tmplist);
        tmplist = (char **)((void *)0);
        tmpentries = 1;
      } else {

      }
      if ((unsigned int )htrobot->dislist != (unsigned int )((void *)0)) {
        http_robots_listfree(htrobot->dislist);
        htrobot->dislist = (char **)((void *)0);
      } else {

      }
      goto __Cont;
    } else {

    }
    tmpentries = tmpentries + 1;
    tmp___11 = realloc((void *)tmplist, (unsigned int )tmpentries * sizeof(char *));
    tmp___1 = (char **)tmp___11;
    if ((unsigned int )tmp___1 != (unsigned int )((void *)0)) {
      tmplist = tmp___1;
      *(tmplist + (tmpentries - 1)) = (char *)((void *)0);
    } else {

    }
    if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
      goto _L;
    } else {
      tmp___12 = strdupend(pa, pe);
      *(tmp___1 + (tmpentries - 2)) = tmp___12;
      if ((unsigned int )tmp___12 == (unsigned int )((void *)0)) {
        _L: /* CIL Label */ 
        if ((unsigned int )tmplist != (unsigned int )((void *)0)) {
          http_robots_listfree(tmplist);
          tmplist = (char **)((void *)0);
          tmpentries = 0;
        } else {

        }
        return;
      } else {

      }
    }
    __Cont: /* CIL Label */ 
    tmp___0 = strspn((char const   *)lend, "\r\n");
    p = lend + tmp___0;
  }
  if ((unsigned int )tmplist != (unsigned int )((void *)0)) {
    if (! (flag & 1)) {
      if ((unsigned int )htrobot->dislist != (unsigned int )((void *)0)) {
        http_robots_listfree(htrobot->dislist);
      } else {

      }
      htrobot->dislist = tmplist;
    } else {
      http_robots_listfree(tmplist);
    }
  } else {

  }
  return;
}
}
#pragma merger(0,"/tmp/cil-T22Z1Hwb.i","-Wall")
size_t strlcat(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n ;
  size_t dlen ;
  size_t tmp ;
  char *tmp___0 ;

  {
  d = dst;
  s = src;
  n = siz;
  while (1) {
    if ((int )*d != 0) {
      if (n != 0U) {

      } else {
        break;
      }
    } else {
      break;
    }
    d = d + 1;
  }
  dlen = (unsigned int )(d - dst);
  n = n - dlen;
  if (n == 0U) {
    tmp = strlen(s);
    return (dlen + tmp);
  } else {

  }
  while (1) {
    if ((int const   )*s != 0) {

    } else {
      break;
    }
    if (n != 1U) {
      tmp___0 = d;
      d = d + 1;
      *tmp___0 = (char )*s;
      n = n - 1U;
    } else {

    }
    s = s + 1;
  }
  *d = (char )'\000';
  return (dlen + (size_t )(s - src));
}
}
#pragma merger(0,"/tmp/cil-xTLFTL6D.i","-Wall")
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n ;
  size_t tmp ;
  char *tmp___0 ;

  {
  d = dst;
  s = src;
  n = siz;
  if (n == 0U) {
    tmp = strlen(s);
    return (tmp);
  } else {

  }
  while (1) {
    if ((int const   )*s != 0) {

    } else {
      break;
    }
    if (n != 1U) {
      tmp___0 = d;
      d = d + 1;
      *tmp___0 = (char )*s;
      n = n - 1U;
    } else {

    }
    s = s + 1;
  }
  *d = (char )'\000';
  return ((unsigned int )(s - src));
}
}
#pragma merger(0,"/tmp/cil-xl0HExJl.i","-Wall")
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
static char bname[4096]  ;
 __attribute__((__nothrow__)) char *dirname(char const   *path___0 ) ;
char *dirname(char const   *path___0 ) 
{ register char const   *endp ;
  size_t tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;

  {
  if ((unsigned int )path___0 == (unsigned int )((void *)0)) {
    strcpy((char * __restrict  )(bname), (char const   * __restrict  )".");
    return (bname);
  } else {
    if ((int const   )*path___0 == 0) {
      strcpy((char * __restrict  )(bname), (char const   * __restrict  )".");
      return (bname);
    } else {

    }
  }
  tmp = strlen(path___0);
  endp = (path___0 + tmp) - 1;
  while (1) {
    if ((unsigned int )endp > (unsigned int )path___0) {
      if ((int const   )*endp == 47) {

      } else {
        break;
      }
    } else {
      break;
    }
    endp = endp - 1;
  }
  while (1) {
    if ((unsigned int )endp > (unsigned int )path___0) {
      if ((int const   )*endp != 47) {

      } else {
        break;
      }
    } else {
      break;
    }
    endp = endp - 1;
  }
  if ((unsigned int )endp == (unsigned int )path___0) {
    if ((int const   )*endp == 47) {
      tmp___0 = "/";
    } else {
      tmp___0 = ".";
    }
    strcpy((char * __restrict  )(bname), (char const   * __restrict  )tmp___0);
    return (bname);
  } else {
    while (1) {
      endp = endp - 1;
      if ((unsigned int )endp > (unsigned int )path___0) {
        if ((int const   )*endp == 47) {

        } else {
          break;
        }
      } else {
        break;
      }
    }
  }
  if ((unsigned int )((endp - path___0) + 1) > sizeof(bname)) {
    tmp___1 = __errno_location();
    *tmp___1 = 36;
    return ((char *)((void *)0));
  } else {

  }
  strncpy((char * __restrict  )(bname), (char const   * __restrict  )path___0, (unsigned int )((endp - path___0) + 1));
  bname[(endp - path___0) + 1] = (char )'\000';
  return (bname);
}
}
#pragma merger(0,"/tmp/cil-a5D0edgR.i","-Wall")
void MD5Transform(uint32 *buf , unsigned char const   *inraw ) ;
static uint32 getu32(unsigned char const   *addr ) 
{ 

  {
  return (((((((unsigned long )*(addr + 3) << 8) | (unsigned long )*(addr + 2)) << 8) | (unsigned long )*(addr + 1)) << 8) | (unsigned long )*(addr + 0));
}
}
static void putu32(uint32 data , unsigned char *addr ) 
{ 

  {
  *(addr + 0) = (unsigned char )data;
  *(addr + 1) = (unsigned char )(data >> 8);
  *(addr + 2) = (unsigned char )(data >> 16);
  *(addr + 3) = (unsigned char )(data >> 24);
  return;
}
}
void MD5Init(struct MD5Context *ctx ) 
{ 

  {
  ctx->buf[0] = 1732584193UL;
  ctx->buf[1] = 4023233417UL;
  ctx->buf[2] = 2562383102UL;
  ctx->buf[3] = 271733878UL;
  ctx->bits[0] = 0UL;
  ctx->bits[1] = 0UL;
  return;
}
}
void MD5Update(struct MD5Context *ctx , unsigned char const   *buf , unsigned int len ) 
{ uint32 t ;
  uint32 tmp ;
  unsigned char *p ;

  {
  t = ctx->bits[0];
  tmp = (t + ((unsigned long )len << 3)) & 4294967295UL;
  ctx->bits[0] = tmp;
  if (tmp < t) {
    ctx->bits[1] = ctx->bits[1] + 1UL;
  } else {

  }
  ctx->bits[1] = ctx->bits[1] + (uint32 )(len >> 29);
  t = (t >> 3) & 63UL;
  if (t) {
    p = ctx->in + t;
    t = 64UL - t;
    if ((uint32 )len < t) {
      memcpy(p, buf, len);
      return;
    } else {

    }
    memcpy(p, buf, t);
    MD5Transform((uint32 *)(ctx->buf), (unsigned char const   *)(ctx->in));
    buf = buf + t;
    len = (unsigned int )((uint32 )len - t);
  } else {

  }
  while (1) {
    if (len >= 64U) {

    } else {
      break;
    }
    memcpy(ctx->in, buf, 64);
    MD5Transform((uint32 *)(ctx->buf), (unsigned char const   *)(ctx->in));
    buf = buf + 64;
    len = len - 64U;
  }
  memcpy(ctx->in, buf, len);
  return;
}
}
void MD5Final(unsigned char *digest___0 , struct MD5Context *ctx ) 
{ unsigned int count ;
  unsigned char *p ;
  unsigned char *tmp ;

  {
  count = (unsigned int )((ctx->bits[0] >> 3) & 63UL);
  p = ctx->in + count;
  tmp = p;
  p = p + 1;
  *tmp = (unsigned char)128;
  count = 63U - count;
  if (count < 8U) {
    memset(p, 0, count);
    MD5Transform((uint32 *)(ctx->buf), (unsigned char const   *)(ctx->in));
    memset(ctx->in, 0, 56);
  } else {
    memset(p, 0, count - 8U);
  }
  putu32(ctx->bits[0], ctx->in + 56);
  putu32(ctx->bits[1], ctx->in + 60);
  MD5Transform((uint32 *)(ctx->buf), (unsigned char const   *)(ctx->in));
  putu32(ctx->buf[0], (unsigned char *)digest___0);
  putu32(ctx->buf[1], (unsigned char *)(digest___0 + 4));
  putu32(ctx->buf[2], (unsigned char *)(digest___0 + 8));
  putu32(ctx->buf[3], (unsigned char *)(digest___0 + 12));
  memset(ctx, 0, sizeof(ctx));
  return;
}
}
void MD5Transform(uint32 *buf , unsigned char const   *inraw ) 
{ register uint32 a ;
  register uint32 b ;
  register uint32 c ;
  register uint32 d ;
  uint32 in[16] ;
  int i ;

  {
  i = 0;
  while (1) {
    if (i < 16) {

    } else {
      break;
    }
    in[i] = getu32((unsigned char const   *)(inraw + 4 * i));
    i = i + 1;
  }
  a = *(buf + 0);
  b = *(buf + 1);
  c = *(buf + 2);
  d = *(buf + 3);
  a = a + (((d ^ (b & (c ^ d))) + in[0]) + 3614090360UL);
  a = a & 4294967295UL;
  a = (a << 7) | (a >> 25);
  a = a + b;
  d = d + (((c ^ (a & (b ^ c))) + in[1]) + 3905402710UL);
  d = d & 4294967295UL;
  d = (d << 12) | (d >> 20);
  d = d + a;
  c = c + (((b ^ (d & (a ^ b))) + in[2]) + 606105819UL);
  c = c & 4294967295UL;
  c = (c << 17) | (c >> 15);
  c = c + d;
  b = b + (((a ^ (c & (d ^ a))) + in[3]) + 3250441966UL);
  b = b & 4294967295UL;
  b = (b << 22) | (b >> 10);
  b = b + c;
  a = a + (((d ^ (b & (c ^ d))) + in[4]) + 4118548399UL);
  a = a & 4294967295UL;
  a = (a << 7) | (a >> 25);
  a = a + b;
  d = d + (((c ^ (a & (b ^ c))) + in[5]) + 1200080426UL);
  d = d & 4294967295UL;
  d = (d << 12) | (d >> 20);
  d = d + a;
  c = c + (((b ^ (d & (a ^ b))) + in[6]) + 2821735955UL);
  c = c & 4294967295UL;
  c = (c << 17) | (c >> 15);
  c = c + d;
  b = b + (((a ^ (c & (d ^ a))) + in[7]) + 4249261313UL);
  b = b & 4294967295UL;
  b = (b << 22) | (b >> 10);
  b = b + c;
  a = a + (((d ^ (b & (c ^ d))) + in[8]) + 1770035416UL);
  a = a & 4294967295UL;
  a = (a << 7) | (a >> 25);
  a = a + b;
  d = d + (((c ^ (a & (b ^ c))) + in[9]) + 2336552879UL);
  d = d & 4294967295UL;
  d = (d << 12) | (d >> 20);
  d = d + a;
  c = c + (((b ^ (d & (a ^ b))) + in[10]) + 4294925233UL);
  c = c & 4294967295UL;
  c = (c << 17) | (c >> 15);
  c = c + d;
  b = b + (((a ^ (c & (d ^ a))) + in[11]) + 2304563134UL);
  b = b & 4294967295UL;
  b = (b << 22) | (b >> 10);
  b = b + c;
  a = a + (((d ^ (b & (c ^ d))) + in[12]) + 1804603682UL);
  a = a & 4294967295UL;
  a = (a << 7) | (a >> 25);
  a = a + b;
  d = d + (((c ^ (a & (b ^ c))) + in[13]) + 4254626195UL);
  d = d & 4294967295UL;
  d = (d << 12) | (d >> 20);
  d = d + a;
  c = c + (((b ^ (d & (a ^ b))) + in[14]) + 2792965006UL);
  c = c & 4294967295UL;
  c = (c << 17) | (c >> 15);
  c = c + d;
  b = b + (((a ^ (c & (d ^ a))) + in[15]) + 1236535329UL);
  b = b & 4294967295UL;
  b = (b << 22) | (b >> 10);
  b = b + c;
  a = a + (((c ^ (d & (b ^ c))) + in[1]) + 4129170786UL);
  a = a & 4294967295UL;
  a = (a << 5) | (a >> 27);
  a = a + b;
  d = d + (((b ^ (c & (a ^ b))) + in[6]) + 3225465664UL);
  d = d & 4294967295UL;
  d = (d << 9) | (d >> 23);
  d = d + a;
  c = c + (((a ^ (b & (d ^ a))) + in[11]) + 643717713UL);
  c = c & 4294967295UL;
  c = (c << 14) | (c >> 18);
  c = c + d;
  b = b + (((d ^ (a & (c ^ d))) + in[0]) + 3921069994UL);
  b = b & 4294967295UL;
  b = (b << 20) | (b >> 12);
  b = b + c;
  a = a + (((c ^ (d & (b ^ c))) + in[5]) + 3593408605UL);
  a = a & 4294967295UL;
  a = (a << 5) | (a >> 27);
  a = a + b;
  d = d + (((b ^ (c & (a ^ b))) + in[10]) + 38016083UL);
  d = d & 4294967295UL;
  d = (d << 9) | (d >> 23);
  d = d + a;
  c = c + (((a ^ (b & (d ^ a))) + in[15]) + 3634488961UL);
  c = c & 4294967295UL;
  c = (c << 14) | (c >> 18);
  c = c + d;
  b = b + (((d ^ (a & (c ^ d))) + in[4]) + 3889429448UL);
  b = b & 4294967295UL;
  b = (b << 20) | (b >> 12);
  b = b + c;
  a = a + (((c ^ (d & (b ^ c))) + in[9]) + 568446438UL);
  a = a & 4294967295UL;
  a = (a << 5) | (a >> 27);
  a = a + b;
  d = d + (((b ^ (c & (a ^ b))) + in[14]) + 3275163606UL);
  d = d & 4294967295UL;
  d = (d << 9) | (d >> 23);
  d = d + a;
  c = c + (((a ^ (b & (d ^ a))) + in[3]) + 4107603335UL);
  c = c & 4294967295UL;
  c = (c << 14) | (c >> 18);
  c = c + d;
  b = b + (((d ^ (a & (c ^ d))) + in[8]) + 1163531501UL);
  b = b & 4294967295UL;
  b = (b << 20) | (b >> 12);
  b = b + c;
  a = a + (((c ^ (d & (b ^ c))) + in[13]) + 2850285829UL);
  a = a & 4294967295UL;
  a = (a << 5) | (a >> 27);
  a = a + b;
  d = d + (((b ^ (c & (a ^ b))) + in[2]) + 4243563512UL);
  d = d & 4294967295UL;
  d = (d << 9) | (d >> 23);
  d = d + a;
  c = c + (((a ^ (b & (d ^ a))) + in[7]) + 1735328473UL);
  c = c & 4294967295UL;
  c = (c << 14) | (c >> 18);
  c = c + d;
  b = b + (((d ^ (a & (c ^ d))) + in[12]) + 2368359562UL);
  b = b & 4294967295UL;
  b = (b << 20) | (b >> 12);
  b = b + c;
  a = a + ((((b ^ c) ^ d) + in[5]) + 4294588738UL);
  a = a & 4294967295UL;
  a = (a << 4) | (a >> 28);
  a = a + b;
  d = d + ((((a ^ b) ^ c) + in[8]) + 2272392833UL);
  d = d & 4294967295UL;
  d = (d << 11) | (d >> 21);
  d = d + a;
  c = c + ((((d ^ a) ^ b) + in[11]) + 1839030562UL);
  c = c & 4294967295UL;
  c = (c << 16) | (c >> 16);
  c = c + d;
  b = b + ((((c ^ d) ^ a) + in[14]) + 4259657740UL);
  b = b & 4294967295UL;
  b = (b << 23) | (b >> 9);
  b = b + c;
  a = a + ((((b ^ c) ^ d) + in[1]) + 2763975236UL);
  a = a & 4294967295UL;
  a = (a << 4) | (a >> 28);
  a = a + b;
  d = d + ((((a ^ b) ^ c) + in[4]) + 1272893353UL);
  d = d & 4294967295UL;
  d = (d << 11) | (d >> 21);
  d = d + a;
  c = c + ((((d ^ a) ^ b) + in[7]) + 4139469664UL);
  c = c & 4294967295UL;
  c = (c << 16) | (c >> 16);
  c = c + d;
  b = b + ((((c ^ d) ^ a) + in[10]) + 3200236656UL);
  b = b & 4294967295UL;
  b = (b << 23) | (b >> 9);
  b = b + c;
  a = a + ((((b ^ c) ^ d) + in[13]) + 681279174UL);
  a = a & 4294967295UL;
  a = (a << 4) | (a >> 28);
  a = a + b;
  d = d + ((((a ^ b) ^ c) + in[0]) + 3936430074UL);
  d = d & 4294967295UL;
  d = (d << 11) | (d >> 21);
  d = d + a;
  c = c + ((((d ^ a) ^ b) + in[3]) + 3572445317UL);
  c = c & 4294967295UL;
  c = (c << 16) | (c >> 16);
  c = c + d;
  b = b + ((((c ^ d) ^ a) + in[6]) + 76029189UL);
  b = b & 4294967295UL;
  b = (b << 23) | (b >> 9);
  b = b + c;
  a = a + ((((b ^ c) ^ d) + in[9]) + 3654602809UL);
  a = a & 4294967295UL;
  a = (a << 4) | (a >> 28);
  a = a + b;
  d = d + ((((a ^ b) ^ c) + in[12]) + 3873151461UL);
  d = d & 4294967295UL;
  d = (d << 11) | (d >> 21);
  d = d + a;
  c = c + ((((d ^ a) ^ b) + in[15]) + 530742520UL);
  c = c & 4294967295UL;
  c = (c << 16) | (c >> 16);
  c = c + d;
  b = b + ((((c ^ d) ^ a) + in[2]) + 3299628645UL);
  b = b & 4294967295UL;
  b = (b << 23) | (b >> 9);
  b = b + c;
  a = a + (((c ^ (b | ~ d)) + in[0]) + 4096336452UL);
  a = a & 4294967295UL;
  a = (a << 6) | (a >> 26);
  a = a + b;
  d = d + (((b ^ (a | ~ c)) + in[7]) + 1126891415UL);
  d = d & 4294967295UL;
  d = (d << 10) | (d >> 22);
  d = d + a;
  c = c + (((a ^ (d | ~ b)) + in[14]) + 2878612391UL);
  c = c & 4294967295UL;
  c = (c << 15) | (c >> 17);
  c = c + d;
  b = b + (((d ^ (c | ~ a)) + in[5]) + 4237533241UL);
  b = b & 4294967295UL;
  b = (b << 21) | (b >> 11);
  b = b + c;
  a = a + (((c ^ (b | ~ d)) + in[12]) + 1700485571UL);
  a = a & 4294967295UL;
  a = (a << 6) | (a >> 26);
  a = a + b;
  d = d + (((b ^ (a | ~ c)) + in[3]) + 2399980690UL);
  d = d & 4294967295UL;
  d = (d << 10) | (d >> 22);
  d = d + a;
  c = c + (((a ^ (d | ~ b)) + in[10]) + 4293915773UL);
  c = c & 4294967295UL;
  c = (c << 15) | (c >> 17);
  c = c + d;
  b = b + (((d ^ (c | ~ a)) + in[1]) + 2240044497UL);
  b = b & 4294967295UL;
  b = (b << 21) | (b >> 11);
  b = b + c;
  a = a + (((c ^ (b | ~ d)) + in[8]) + 1873313359UL);
  a = a & 4294967295UL;
  a = (a << 6) | (a >> 26);
  a = a + b;
  d = d + (((b ^ (a | ~ c)) + in[15]) + 4264355552UL);
  d = d & 4294967295UL;
  d = (d << 10) | (d >> 22);
  d = d + a;
  c = c + (((a ^ (d | ~ b)) + in[6]) + 2734768916UL);
  c = c & 4294967295UL;
  c = (c << 15) | (c >> 17);
  c = c + d;
  b = b + (((d ^ (c | ~ a)) + in[13]) + 1309151649UL);
  b = b & 4294967295UL;
  b = (b << 21) | (b >> 11);
  b = b + c;
  a = a + (((c ^ (b | ~ d)) + in[4]) + 4149444226UL);
  a = a & 4294967295UL;
  a = (a << 6) | (a >> 26);
  a = a + b;
  d = d + (((b ^ (a | ~ c)) + in[11]) + 3174756917UL);
  d = d & 4294967295UL;
  d = (d << 10) | (d >> 22);
  d = d + a;
  c = c + (((a ^ (d | ~ b)) + in[2]) + 718787259UL);
  c = c & 4294967295UL;
  c = (c << 15) | (c >> 17);
  c = c + d;
  b = b + (((d ^ (c | ~ a)) + in[9]) + 3951481745UL);
  b = b & 4294967295UL;
  b = (b << 21) | (b >> 11);
  b = b + c;
  *(buf + 0) = *(buf + 0) + a;
  *(buf + 1) = *(buf + 1) + b;
  *(buf + 2) = *(buf + 2) + c;
  *(buf + 3) = *(buf + 3) + d;
  return;
}
}
