%!TEX root = paper.tex

\section{Problem Definition and Solution Overview}
In the following, we assume that a program contains a finite set of integer variable $\{x,y,z,\cdots\}$ 
and thus a program state is a valuation of the variables. 
A predicate on the variables is viewed as the maximum set of program states which satisfies the predicate. 
We use predicates and sets of program states interchangeably. 
Without loss of generality, we assume the input to \textsc{Zilu} is a Hoare triple
\[
\{Pre\} \\
while~(Cond) \{ \\
~~~~~~Body \\
\} \\
\{Post\}
\]
where $Pre$ is the pre-condition, which should be satisfied before entering the loop; 
$Cond$ is the loop guard condition, which is the only way to enter or exit the loop $Body$; 
$Body$ is the loop body, in which we assume there is no \emph{break} or \emph{goto} statement which can jump out of the loop without checking $cond$; 
and $Post$ is the post-condition, which should be satisfied after the loop. 

For simplicity, we assume that $Body$ is a function such that $Body(s) = s'$ means 
that starting at a program state $s$, executing $Body$ would result in a program state $s'$. 
Furthermore, we write $Body(Pr)$ where $Pr$ to denote the set $\{s' | \exists s \in Pr: Body(s) = s'\}$. 
The goal is thus to automatically obtain a loop invariant such that that the following conditions are satisfied.
\[
Pre \implies Inv ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(1) \\
Inv \implies Body(Inv \land Cond) ~~~~~~~~~~~~~~~~~~ (2) \\
Inv \land \neg Cond \implies Post ~~~~~~~~~~~~~~~~~~~~~~~~~ (3)
\]
%where $Inv'$ is the predicate obtained by replacing every variable in $Inv$ with its primed version, denoting the set of program states after executing $Body$.

\begin{figure}[t]
\centering
\begin{minipage}{.5\textwidth}
  \centering
{\scriptsize
\begin{verbatim}
    void ex1 (int x) {
        int y = 355;
        if (x > 46) x = 46;
        while (x <= 100) {
            if (x >= 46) {
                y = y+1;
            }
            x = x + 1;
        }
        assert(y==409);
    }
\end{verbatim}}
  \caption{An example adopted from~\cite{DBLP:conf/popl/GulwaniJ07}}
  \label{fig:test1}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
{\scriptsize\begin{verbatim}
    void ex2 () {
        lock=0;new=old+1;
        while (new!=old) {
            lock=1;old=new;
            if (foo(new)) {
                lock=0;new++;
            }
        }
        if (lock==0)
            error();
    }
\end{verbatim}}
  \caption{An example adopted from~\cite{DBLP:conf/popl/HenzingerJMS02}}
  \label{fig:test2}
\end{minipage}
\end{figure}

\begin{example}
We use the two examples shown in Figure~\ref{fig:test1} and~\ref{fig:test2} to illustrate how our approach works. 
In $ex1$, the precondition of the loop is $y = 355 \land x \leq 46$ and the post-condition is $y=409$. 
In $ex2$, the precondition is that $lock=0 \land new=old+1$ and the post-condition (necessary so that there is no error) is $lock=1$. 
We remark that $foo(new)$ is an external function which \emph{deterministically} returns either true or false, 
i.e., it returns true if $new$ is even; otherwise, it returns false. 
We will discuss in Section how our approach would work if $foo(new)$ is non-deterministic.
\end{example}

\paragraph{Problem Definition} In this work, we assume that given the Hoare triple, 
there is either a counterexample (i.e., a program state $s$ such that $s \in Pre$ and executing the program from $s$ results in failing $post$) 
or there exists an invariant satisfying (1) and (2) and (3). 
Furthermore, the invariant $inv$ is a boolean formula over a linear inequality constraint 
of the form $ax + bx + \cdots \geq d$ where $a,b,d$ are bounded integer constants; 
and $inv$ contains no more than $k$ such statements. 
We remark that such invariant is in general not convex and thus existing approaches on learning convex invariants do not work~\cite{}.

\paragraph{Overview of Our Approach} 
Our approach to solve the problem is illustrated in Figure~\ref{overview}. 
Firstly, we randomly generate a set of program states right before the loop and test the program. 
Based on the testing results, we obtain program states which must or must not satisfy any invariant satisfying (1), (2) and (3). 
Secondly, we develop an algorithm for generating candidate invariants based classification techniques from the machine learning community. 
Thirdly, to overcome the limitation of the sampled program states, 
we adopt active learning techniques, in particular, selective sampling, to refine the candidate invariants. 
Lastly, we rely on constraint solving techniques to check whether the generate invariant satisfies (1) and (2) and (3). 
If it does, we report that our approach is successful; 
otherwise, using the counterexamples generated by the constraint solvers, we repeat from the second step. 
In this following sections, we present details of each step.
